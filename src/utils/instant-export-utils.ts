import { GameConfig } from '../types';

// --- RGS SCHEMA DEFINITIONS (v1.0.0) ---
// These mirror the RGS Schema used in scratch-export-utils but extended for Instant Games

export interface RGSMechanic {
    type: string;
    // Plinko Specifics
    rows?: number;
    risk?: string;
    // Mines Specifics
    grid_size?: number;
    mine_count?: number;
    // Coin Flip Specifics
    coin_theme?: string;
    coin_side?: string;
}

export interface RGSPrizeTier {
    tier: string;
    multiplier: number;
    probability: number;
}

export interface RGSMathSchema {
    schema_version: number;
    model_id: string;
    model_version: string;
    mechanic: RGSMechanic;
    prize_table?: RGSPrizeTier[];
    stats?: {
        rtp: number;
        max_win: number;
    };
    integrity?: {
        content_hash: string;
    };
}

export interface RGSExportPayload {
    meta: {
        exportedAt: string;
        version: string;
        type: string;
        generator: string;
    };
    visuals: Partial<GameConfig>;
    math: RGSMathSchema;
}

/**
 * Transforms the Instant Game Config into an RGS Math Schema.
 */
export const transformToRGS = (config: GameConfig): RGSMathSchema => {
    const type = config.instantGameType || 'plinko';
    const settings = config.instantGameConfig || {};

    const mechanic: RGSMechanic = {
        type: type
    };

    let prizes: RGSPrizeTier[] = [];
    let stats = { rtp: 0.97, max_win: 0 };

    if (type === 'plinko') {
        mechanic.rows = settings.plinko?.rows || 12;
        mechanic.risk = settings.plinko?.risk || 'medium';
        // Plinko prizes are usually procedurally generated by the engine based on risk/rows
        // But we can export the "buckets" if known. For now, we delegate to engine.
        stats.max_win = mechanic.risk === 'high' ? 1000 : 100;
    }
    else if (type === 'mines') {
        mechanic.grid_size = settings.mines?.gridSize || 5;
        mechanic.mine_count = settings.mines?.mineCount || 3;
        // Mines is dynamic, max win depends on how far you go.
        // multi = (48-mines)! / (48-mines-picks)! ... complex combinatorics.
        stats.max_win = 10000; // Cap
    }
    else if (type === 'coin_flip') {
        mechanic.coin_theme = settings.coin?.theme || 'gold';
        mechanic.coin_side = settings.coin?.side || 'heads';

        prizes = [
            { tier: 'WIN', multiplier: 1.96, probability: 0.5 },
            { tier: 'LOSE', multiplier: 0, probability: 0.5 }
        ];
        stats.rtp = 0.98;
        stats.max_win = 1.96;
    }

    return {
        schema_version: 1,
        model_id: config.gameId || `instant_${type}`,
        model_version: '1.0.0',
        mechanic,
        prize_table: prizes.length > 0 ? prizes : undefined,
        stats,
        integrity: {
            content_hash: 'pending_certification'
        }
    };
};

/**
 * Generates the complete export payload for RGS.
 */
export const generateInstantExport = (config: GameConfig): RGSExportPayload => {
    const rgsMath = transformToRGS(config);

    return {
        meta: {
            exportedAt: new Date().toISOString(),
            version: '1.0.0',
            type: 'instant_win',
            generator: 'GameCrafter Studio'
        },
        visuals: {
            instantGameType: config.instantGameType,
            instantGameConfig: config.instantGameConfig,
            theme: config.theme,
            background: config.background
        },
        math: rgsMath
    };
};
