import React, { useState, useEffect, useRef } from 'react';
import { UiDesigns, useGameStore } from '../../../store';
import { motion, AnimatePresence } from 'framer-motion';
import { adaptiveButtonDetector } from '../../../utils/adaptiveButtonDetection';
import {
  Image, Wand2, RefreshCw, CheckCircle, AlertCircle, Loader, Sparkles, Upload, Settings,
  Move, ArrowUpDown, ArrowLeftRight, ZoomIn, Volume2, Info, Play, Menu, Grid3X3,
  Maximize, Copy, Sun, Moon, RotateCcw, Layers
} from 'lucide-react';
import { enhancedOpenaiClient } from '../../../utils/enhancedOpenaiClient';
import { detectDeviceType, onDeviceTypeChange, getDefaultLogoPosition, getDefaultLogoScale, DeviceType } from '../../../utils/deviceDetection';
import { Button } from '../../Button';
import { slotApiClient } from '../../../utils/apiClient';
import { useSuccessPopup, useWarningPopup } from '../../popups';


interface AssetConfig {
  // Background properties
  backgroundPath: string | null;
  backgroundStyle: string;
  backgroundPrompt: string;
  isGeneratingBackground: boolean;

  // Derived backgrounds for different game modes
  derivedBackgrounds: {
    night?: string;
    day?: string;
    bonus?: string;
    freespin?: string;
  };
  isDeriving: boolean;
  derivingType: string | null;
  derivePrompt: string;
  backgroundResponseId?: string;
  backgroundPosition: { x: number; y: number };
  backgroundScale: number;
  backgroundFit: 'cover' | 'contain' | 'fill' | 'scale-down';

  // Frame properties
  framePath: string | null;
  frameStyle: 'outer' | 'reel' | 'both';
  framePrompt: string;
  isGeneratingFrame: boolean;
  framePosition: { x: number; y: number };
  frameScale: number;
  frameStretch: { x: number; y: number };

  // Reel divider properties (for 'reel' frame style)
  reelGap: number;
  reelDividerPosition: { x: number; y: number };
  reelDividerStretch: { x: number; y: number };

  // Individual reel backgrounds (generated by clicking on reels)
  individualReelBackgrounds: string[];

  // AI-generated reel image (for reel frame style)
  aiReelImage: string | null;
  aiReelPrompt: string;
  isGeneratingAIReel: boolean;

  // UI Button properties
  uiButtonsPath: string | null;
  uiButtonsPrompt: string;
  isGeneratingUIButtons: boolean;
  isGeneratingButtonStates: boolean;
  uiElements: {
    spinButton?: string;
    autoplayButton?: string;
    menuButton?: string;
    soundButton?: string;
    settingsButton?: string;
  }
  uiElementsPressed?: {
    spinButton?: string;
    autoplayButton?: string;
    menuButton?: string;
    soundButton?: string;
    settingsButton?: string;
  }
  uiElementsDisabled?: {
    spinButton?: string;
    autoplayButton?: string;
    menuButton?: string;
    soundButton?: string;
    settingsButton?: string;
  }
  // Store the image IDs for generated buttons to use as source for state generation
  uiButtonImageIds?: {
    spinButton?: string;
    autoplayButton?: string;
    menuButton?: string;
    soundButton?: string;
    settingsButton?: string;
  }
  buttonLayoutStyle?: 'horizontal' | 'corner';
  extractedUIButtons?: { [key: string]: string };
  uiButtonsPosition: { x: number; y: number };
  uiButtonsScale: number;
  uiButtonScales?: {
    spinButton?: number;
    autoplayButton?: number;
    menuButton?: number;
    soundButton?: number;
    settingsButton?: number;
  };
  uiButtonPositions?: {
    spinButton?: { x: number; y: number };
    autoplayButton?: { x: number; y: number };
    menuButton?: { x: number; y: number };
    soundButton?: { x: number; y: number };
    settingsButton?: { x: number; y: number };
  };
  uiButtonsVisibility: boolean;

  // Title Assets properties
  titleAssets: {
    freeSpins?: string;
    bonusGame?: string;
    pickAndClick?: string;
    bigWin?: string;
    megaWin?: string;
    jackpot?: string;
    gameOver?: string;
    congratulations?: string;
  };
  titleAssetsStyle: string;
  titleAssetsPrompt: string;
  isGeneratingTitleAssets: boolean;
  currentTitleType: string;
  buttonScale?: number;
  buttonSpacing?: number;

  // Logo properties
  logoPath: string | null;
  logoPrompt: string;
  isGeneratingLogo: boolean;
  logoPositions: {
    desktop: { x: number; y: number };
    mobilePortrait: { x: number; y: number };
    mobileLandscape: { x: number; y: number };
  };
  logoScales: {
    desktop: number;
    mobilePortrait: number;
    mobileLandscape: number;
  };
  currentDevice: 'desktop' | 'mobilePortrait' | 'mobileLandscape';

  // Advanced Grid & Symbol positioning
  showSymbolGrid: boolean;
  gridPosition: { x: number; y: number };
  gridScale: number;
  gridStretch: { x: number; y: number };
  // Win display (big win / win splash) image
  winDisplayImage?: string | null;
  winDisplayPrompt?: string;
  isGeneratingWinDisplay?: boolean;
  winDisplayPositions: {
    desktop: { x: number; y: number };
    mobilePortrait: { x: number; y: number };
    mobileLandscape: { x: number; y: number };
  };
  winDisplayScales: {
    desktop: number;
    mobilePortrait: number;
    mobileLandscape: number;
  };
}

// Main component
const Step6_GameAssets: React.FC = () => {
  const { showSuccess, } = useSuccessPopup();
  const { showWarning } = useWarningPopup()
  const { config, updateConfig, uiType, setUiType } = useGameStore();
  const [activeTab, setActiveTab] = useState<'preset' | 'advanced'>('preset');
  const [backgroundPreviewDevice, setBackgroundPreviewDevice] = useState<'desktop' | 'mobile-portrait' | 'mobile-landscape'>('desktop');
  const [gridOptimize, setGridOptimize] = useState<String>('minimal');
  const [symbolGridClicked, setSymbolGridClicked] = useState(true);



  // File upload references
  const backgroundFileInputRef = useRef<HTMLInputElement>(null);
  const frameFileInputRef = useRef<HTMLInputElement>(null);
  const uiButtonsFileInputRef = useRef<HTMLInputElement>(null);
  const logoFileInputRef = useRef<HTMLInputElement>(null);
  const winDisplayFileInputRef = useRef<HTMLInputElement>(null);

  // --- Add at the top of Step6_GameAssets, after the other useState/useRef ---
  const [selectedUIButton, setSelectedUIButton] = useState<keyof typeof assetConfig.uiElements | null>(null);
  const [singleUIButtonPrompt, setSingleUIButtonPrompt] = useState('');
  const singleUIButtonFileInputRef = useRef<HTMLInputElement>(null);
  
  // Ref to track previous assetConfig values to prevent infinite loops
  const prevAssetConfigRef = useRef<AssetConfig | null>(null);

  // Initialize asset config from store
  const [assetConfig, setAssetConfig] = useState<AssetConfig>({
    backgroundPath: config.background?.backgroundImage || null,
    backgroundStyle: config.background?.style || 'nature',
    backgroundPrompt: '',
    isGeneratingBackground: false,

    derivedBackgrounds: config.derivedBackgrounds || {},
    isDeriving: false,
    derivingType: null,
    derivePrompt: '',
    backgroundResponseId: config.backgroundResponseId,
    backgroundPosition: config.backgroundPosition || { x: 0, y: 0 },
    backgroundScale: config.backgroundScale || 100,
    backgroundFit: config.backgroundFit || 'cover',

    framePath: typeof config.frame === 'string' ? config.frame : null,
    frameStyle: config.frameStyle || 'outer',
    framePrompt: '',
    isGeneratingFrame: false,
    framePosition: config.framePosition || { x: 0, y: 0 },
    frameScale: config.frameScale || 100,
    frameStretch: config.frameStretch || { x: 100, y: 100 },

    // Reel divider defaults - load from store
    reelGap: config.reelGap || 10,
    reelDividerPosition: config.reelDividerPosition || { x: 0, y: 0 },
    reelDividerStretch: config.reelDividerStretch || { x: 100, y: 100 },

    // Individual reel backgrounds defaults
    individualReelBackgrounds: [],

    // AI reel image defaults - load from store
    aiReelImage: config.aiReelImage || null,
    aiReelPrompt: '',
    isGeneratingAIReel: false,

    uiButtonsPath: config.uiButtonsPath || null,
    uiButtonsPrompt: '',
    isGeneratingUIButtons: false,
    isGeneratingButtonStates: false,
    uiElements: config.uiElements || {
      spinButton: null,
      autoplayButton: null,
      menuButton: null,
      soundButton: null,
      settingsButton: null
    },
    uiElementsPressed: config.uiElementsPressed || {},
    uiElementsDisabled: (config as any).uiElementsDisabled || {},
    uiButtonImageIds: (config as any).uiButtonImageIds || {},
    buttonLayoutStyle: config.buttonLayoutStyle || 'horizontal',
    extractedUIButtons: (config as any).extractedUIButtons || {},
    uiButtonsPosition: (config as any).uiButtonsPosition || { x: 0, y: 0 },
    uiButtonsScale: (config as any).uiButtonsScale || 100,
    uiButtonScales: (config as any).uiButtonScales || {
      spinButton: 100,
      autoplayButton: 100,
      menuButton: 100,
      soundButton: 100,
      settingsButton: 100
    },
    uiButtonPositions: (config as any).uiButtonPositions || {
      spinButton: { x: 0, y: 0 },
      autoplayButton: { x: 0, y: 0 },
      menuButton: { x: 0, y: 0 },
      soundButton: { x: 0, y: 0 },
      settingsButton: { x: 0, y: 0 }
    },
    uiButtonsVisibility: (config as any).uiButtonsVisibility !== undefined ? (config as any).uiButtonsVisibility : true,
    buttonScale: config.buttonScale || 100,
    buttonSpacing: config.buttonSpacing || 20,

    // Title Assets
    titleAssets: config.titleAssets || {},
    titleAssetsStyle: config.titleAssetsStyle || 'Golden Elegant',
    titleAssetsPrompt: '',
    isGeneratingTitleAssets: false,
    currentTitleType: 'freeSpins',

    logoPath: config.logo || null,
    logoPrompt: '',
    isGeneratingLogo: false,
    logoPositions: config.logoPositions || {
      desktop: getDefaultLogoPosition('desktop'),
      mobilePortrait: getDefaultLogoPosition('mobilePortrait'),
      mobileLandscape: getDefaultLogoPosition('mobileLandscape')
    },
    logoScales: config.logoScales || {
      desktop: getDefaultLogoScale('desktop'),
      mobilePortrait: getDefaultLogoScale('mobilePortrait'),
      mobileLandscape: getDefaultLogoScale('mobileLandscape')
    },
    currentDevice: detectDeviceType(),

    // Advanced settings - load from global config or localStorage
    showSymbolGrid: config.showSymbolBackgrounds !== undefined ? !config.showSymbolBackgrounds : (() => {
      const saved = localStorage.getItem('symbolGridActive');
      return saved ? JSON.parse(saved) : true;
    })(),
    gridPosition: config.gridPosition || { x: 0, y: 0 },
    gridScale: config.gridScale || 120, // Default to 120% but slider will show as 100
    gridStretch: config.gridStretch || { x: 100, y: 100 }
    ,
    // Win display defaults
    winDisplayImage: (config as any).winDisplayImage || null,
    winDisplayPrompt: (config as any).winDisplayPrompt || '',
    isGeneratingWinDisplay: false,
    winDisplayPositions: (config as any).winDisplayPositions || {
      desktop: { x: 50, y: 20 },
      mobilePortrait: { x: 50, y: 20 },
      mobileLandscape: { x: 50, y: 20 }
    },
    winDisplayScales: (config as any).winDisplayScales || {
      desktop: 80,
      mobilePortrait: 80,
      mobileLandscape: 80
    }
  });

  // Sync assetConfig from store when component mounts
  // This ensures values persist when navigating between steps (component remounts)
  useEffect(() => {
    // Only sync on mount - check if store has different values than initial state
    // This prevents overwriting user's current edits while ensuring persistence on remount
    const storeBackgroundPosition = config.backgroundPosition || { x: 0, y: 0 };
    const storeBackgroundScale = config.backgroundScale || 100;
    const storeBackgroundFit = config.backgroundFit || 'cover';
    const storeFramePosition = config.framePosition || { x: 0, y: 0 };
    const storeFrameScale = config.frameScale || 100;
    const storeFrameStretch = config.frameStretch || { x: 100, y: 100 };
    const storeReelGap = config.reelGap || 10;
    const storeReelDividerPosition = config.reelDividerPosition || { x: 0, y: 0 };
    const storeReelDividerStretch = config.reelDividerStretch || { x: 100, y: 100 };
    const storeUiButtonsPosition = (config as any).uiButtonsPosition || { x: 0, y: 0 };
    const storeUiButtonsScale = (config as any).uiButtonsScale || 100;
    const storeUiButtonScales = (config as any).uiButtonScales || {
      spinButton: 100,
      autoplayButton: 100,
      menuButton: 100,
      soundButton: 100,
      settingsButton: 100
    };
    const storeUiButtonPositions = (config as any).uiButtonPositions || {
      spinButton: { x: 0, y: 0 },
      autoplayButton: { x: 0, y: 0 },
      menuButton: { x: 0, y: 0 },
      soundButton: { x: 0, y: 0 },
      settingsButton: { x: 0, y: 0 }
    };
    const storeUiButtonsVisibility = (config as any).uiButtonsVisibility !== undefined ? (config as any).uiButtonsVisibility : true;
    const storeGridPosition = config.gridPosition || { x: 0, y: 0 };
    const storeGridScale = config.gridScale || 120;
    const storeGridStretch = config.gridStretch || { x: 100, y: 100 };
    const storeWinDisplayPositions = (config as any).winDisplayPositions || {
      desktop: { x: 50, y: 20 },
      mobilePortrait: { x: 50, y: 20 },
      mobileLandscape: { x: 50, y: 20 }
    };
    const storeWinDisplayScales = (config as any).winDisplayScales || {
      desktop: 80,
      mobilePortrait: 80,
      mobileLandscape: 80
    };

    setAssetConfig(prev => {
      // Check if store values are different from current local values
      const needsUpdate = 
        JSON.stringify(prev.backgroundPosition) !== JSON.stringify(storeBackgroundPosition) ||
        prev.backgroundScale !== storeBackgroundScale ||
        prev.backgroundFit !== storeBackgroundFit ||
        JSON.stringify(prev.framePosition) !== JSON.stringify(storeFramePosition) ||
        prev.frameScale !== storeFrameScale ||
        JSON.stringify(prev.frameStretch) !== JSON.stringify(storeFrameStretch) ||
        prev.reelGap !== storeReelGap ||
        JSON.stringify(prev.reelDividerPosition) !== JSON.stringify(storeReelDividerPosition) ||
        JSON.stringify(prev.reelDividerStretch) !== JSON.stringify(storeReelDividerStretch) ||
        JSON.stringify(prev.uiButtonsPosition) !== JSON.stringify(storeUiButtonsPosition) ||
        prev.uiButtonsScale !== storeUiButtonsScale ||
        JSON.stringify(prev.uiButtonScales) !== JSON.stringify(storeUiButtonScales) ||
        JSON.stringify(prev.uiButtonPositions) !== JSON.stringify(storeUiButtonPositions) ||
        prev.uiButtonsVisibility !== storeUiButtonsVisibility ||
        JSON.stringify(prev.gridPosition) !== JSON.stringify(storeGridPosition) ||
        prev.gridScale !== storeGridScale ||
        JSON.stringify(prev.gridStretch) !== JSON.stringify(storeGridStretch) ||
        JSON.stringify(prev.winDisplayPositions) !== JSON.stringify(storeWinDisplayPositions) ||
        JSON.stringify(prev.winDisplayScales) !== JSON.stringify(storeWinDisplayScales);

      if (!needsUpdate) {
        return prev; // No changes needed
      }

      // Update with values from store, preserving any non-persisted state
      return {
        ...prev,
        backgroundPosition: storeBackgroundPosition,
        backgroundScale: storeBackgroundScale,
        backgroundFit: storeBackgroundFit,
        framePosition: storeFramePosition,
        frameScale: storeFrameScale,
        frameStretch: storeFrameStretch,
        reelGap: storeReelGap,
        reelDividerPosition: storeReelDividerPosition,
        reelDividerStretch: storeReelDividerStretch,
        uiButtonsPosition: storeUiButtonsPosition,
        uiButtonsScale: storeUiButtonsScale,
        uiButtonScales: storeUiButtonScales,
        uiButtonPositions: storeUiButtonPositions,
        uiButtonsVisibility: storeUiButtonsVisibility,
        gridPosition: storeGridPosition,
        gridScale: storeGridScale,
        gridStretch: storeGridStretch,
        winDisplayPositions: storeWinDisplayPositions,
        winDisplayScales: storeWinDisplayScales
      };
    });
  }, []); // Only run on mount

  // Device detection and orientation change handling
  useEffect(() => {
    const cleanup = onDeviceTypeChange((newDeviceType: DeviceType) => {
      updateAssetConfig('currentDevice', newDeviceType);
    });

    return cleanup;
  }, []);

  // Listen for individual reel background generation from PixiJS preview
  useEffect(() => {
    const handleReelBackgroundGenerated = (event: CustomEvent) => {
      const { reelBackgrounds } = event.detail;

      // Update individual reel backgrounds array
      updateAssetConfig('individualReelBackgrounds', reelBackgrounds);

    };

    window.addEventListener('reelBackgroundGenerated', handleReelBackgroundGenerated as EventListener);

    return () => {
      window.removeEventListener('reelBackgroundGenerated', handleReelBackgroundGenerated as EventListener);
    };
  }, []);

  // Generate AI reel image for reel frame style
  const generateAIReel = async () => {
    updateAssetConfig('isGeneratingAIReel', true);

    try {
      // Get theme name
      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || config.theme?.name || 'casino');

      // Get current grid dimensions
      const reels = config.reels?.layout?.reels || 5;
      const rows = config.reels?.layout?.rows || 3;

      // Custom prompt or auto-generate
      const customPrompt = assetConfig.aiReelPrompt.trim();
      const basePrompt = customPrompt || `${themeName} themed reel separator`;


      const enhancedPrompt = `Create a vertical reel separator/divider image for a ${themeName} themed slot machine game.

      REEL SEPARATOR SPECIFICATIONS:
      - Vertical orientation (taller than wide, aspect ratio 1:12 or 1:14)
      - Will be used as dividers between reel columns
      - Grid layout: ${reels} columns Ã— ${rows} rows
      - Professional casino-quality appearance

      VISUAL REQUIREMENTS:
      - ${basePrompt}
      - Elegant vertical design that separates reel columns
      - Colors that complement the ${themeName} theme
      - Metallic or ornate finish appropriate to theme
      - Subtle texture and detailing
      - Professional, refined appearance

      DESIGN ELEMENTS:
      - Vertical gradient or pattern
      - Decorative elements that match ${themeName} style
      - Appropriate lighting and shadows
      - High-quality materials (gold, silver, bronze, etc.)
      - Elegant borders or trim details

      TECHNICAL SPECIFICATIONS:
      - Vertical orientation optimized for reel separation
      - PNG format with transparency support where appropriate
      - High contrast against symbol backgrounds
      - Seamless integration with ${themeName} theme
      - Professional casino-grade quality

      Create a beautiful reel separator that enhances the ${themeName} slot machine experience!`;

      // Generate the AI reel image
      const result = await enhancedOpenaiClient.generateImageWithConfig({
        prompt: enhancedPrompt,
        targetSymbolId: 'ai_reel_separator',
        gameId: config.gameId,
        count: 1,
        size: '1024x1536'
      });

      if (result && result.success && result.images && result.images.length > 0) {
        const imageUrl = result.images[0];

        // Update both local and global config with generated image
        updateAssetConfig('aiReelImage', imageUrl);
        updateConfig({
          aiReelImage: imageUrl,
          frameStyle: 'reel' // Ensure frame style is set to reel when AI reel is generated
        });

        // Save to API with gameStore data
        const gameId = config.gameId || `${themeName || 'slot'}_${new Date().toISOString().split('T')[0]}`.toLowerCase().replace(/[^a-z0-9]/g, '_');
        if (gameId) {
          try {
            const gameStoreData = useGameStore.getState().config;
            await slotApiClient.saveGameConfig(gameId, gameStoreData);
          } catch (error) {
            console.error('Failed to save AI reel config to API:', error);
          }
        }

        // Dispatch specific event for reel frame updates (not generic preview update)
        window.dispatchEvent(new CustomEvent('aiReelImageUpdated', {
          detail: {
            aiReelImage: imageUrl,
            frameStyle: 'reel',
            updateType: 'reel-only' // Indicate this should only update reel dividers
          }
        }));

        showSuccess("Success", 'AI reel image generated successfully!');
      } else {
        console.error('Failed to generate AI reel image');
        showWarning('Error', 'Failed to generate AI reel image. Please try again.');
      }
    } catch (error) {
      console.error('Error generating AI reel image:', error);
      showWarning('Error', 'Failed to generate AI reel image. Please try again.');
    } finally {
      updateAssetConfig('isGeneratingAIReel', false);
    }
  };

  // No automatic mockup loading - users must explicitly generate or upload assets

  // Update store when asset config changes - using ref to prevent infinite loops
  useEffect(() => {
    // Skip if this is the initial mount
    if (prevAssetConfigRef.current === null) {
      prevAssetConfigRef.current = { ...assetConfig };
      return;
    }

    // Only update config if relevant values actually changed
    const prev = prevAssetConfigRef.current;
    
    // Check UI button related changes (most common)
    const uiButtonChanges = 
      JSON.stringify(prev.uiButtonsPosition) !== JSON.stringify(assetConfig.uiButtonsPosition) ||
      prev.uiButtonsScale !== assetConfig.uiButtonsScale ||
      JSON.stringify(prev.uiButtonScales) !== JSON.stringify(assetConfig.uiButtonScales) ||
      prev.uiButtonsVisibility !== assetConfig.uiButtonsVisibility ||
      JSON.stringify(prev.uiElements) !== JSON.stringify(assetConfig.uiElements) ||
      JSON.stringify(prev.uiElementsPressed) !== JSON.stringify(assetConfig.uiElementsPressed) ||
      JSON.stringify(prev.uiElementsDisabled) !== JSON.stringify(assetConfig.uiElementsDisabled) ||
      JSON.stringify(prev.uiButtonImageIds) !== JSON.stringify(assetConfig.uiButtonImageIds) ||
      JSON.stringify(prev.extractedUIButtons) !== JSON.stringify(assetConfig.extractedUIButtons) ||
      prev.uiButtonsPath !== assetConfig.uiButtonsPath;

    // Check other changes
    const otherChanges = 
      prev.framePath !== assetConfig.framePath ||
      prev.frameStyle !== assetConfig.frameStyle ||
      JSON.stringify(prev.framePosition) !== JSON.stringify(assetConfig.framePosition) ||
      prev.frameScale !== assetConfig.frameScale ||
      JSON.stringify(prev.frameStretch) !== JSON.stringify(assetConfig.frameStretch) ||
      prev.reelGap !== assetConfig.reelGap ||
      JSON.stringify(prev.reelDividerPosition) !== JSON.stringify(assetConfig.reelDividerPosition) ||
      JSON.stringify(prev.reelDividerStretch) !== JSON.stringify(assetConfig.reelDividerStretch) ||
      prev.aiReelImage !== assetConfig.aiReelImage ||
      prev.backgroundPath !== assetConfig.backgroundPath ||
      prev.backgroundStyle !== assetConfig.backgroundStyle ||
      JSON.stringify(prev.derivedBackgrounds) !== JSON.stringify(assetConfig.derivedBackgrounds) ||
      prev.backgroundResponseId !== assetConfig.backgroundResponseId ||
      JSON.stringify(prev.backgroundPosition) !== JSON.stringify(assetConfig.backgroundPosition) ||
      prev.backgroundScale !== assetConfig.backgroundScale ||
      prev.backgroundFit !== assetConfig.backgroundFit ||
      prev.logoPath !== assetConfig.logoPath ||
      JSON.stringify(prev.logoPositions) !== JSON.stringify(assetConfig.logoPositions) ||
      JSON.stringify(prev.logoScales) !== JSON.stringify(assetConfig.logoScales) ||
      prev.currentDevice !== assetConfig.currentDevice ||
      JSON.stringify(prev.gridPosition) !== JSON.stringify(assetConfig.gridPosition) ||
      prev.gridScale !== assetConfig.gridScale ||
      JSON.stringify(prev.gridStretch) !== JSON.stringify(assetConfig.gridStretch) ||
      prev.winDisplayImage !== assetConfig.winDisplayImage ||
      JSON.stringify(prev.winDisplayPositions) !== JSON.stringify(assetConfig.winDisplayPositions) ||
      JSON.stringify(prev.winDisplayScales) !== JSON.stringify(assetConfig.winDisplayScales);

    if (!uiButtonChanges && !otherChanges) {
      // No changes, update ref and return
      prevAssetConfigRef.current = { ...assetConfig };
      return;
    }

    // Skip redundant safeguard for UI buttons - event system handles real-time updates

    // Update the ref BEFORE calling updateConfig to prevent loops
    prevAssetConfigRef.current = { ...assetConfig };

    updateConfig({
      frame: assetConfig.framePath,
      frameStyle: assetConfig.frameStyle,
      framePosition: assetConfig.framePosition,
      frameScale: assetConfig.frameScale,
      frameStretch: assetConfig.frameStretch,
      // Reel divider properties
      reelGap: assetConfig.reelGap,
      reelDividerPosition: assetConfig.reelDividerPosition,
      reelDividerStretch: assetConfig.reelDividerStretch,
      aiReelImage: assetConfig.aiReelImage,
      background: {
        ...config.background,
        backgroundImage: assetConfig.backgroundPath,
        style: assetConfig.backgroundStyle
      },
      derivedBackgrounds: assetConfig.derivedBackgrounds,
      backgroundResponseId: assetConfig.backgroundResponseId,
      uiButtonsPath: assetConfig.uiButtonsPath,
      uiElements: assetConfig.uiElements,
      uiElementsPressed: assetConfig.uiElementsPressed,
      uiElementsDisabled: assetConfig.uiElementsDisabled,
      uiButtonImageIds: assetConfig.uiButtonImageIds,
      uiButtonsPosition: assetConfig.uiButtonsPosition,
      uiButtonsScale: assetConfig.uiButtonsScale,
      uiButtonScales: assetConfig.uiButtonScales,
      uiButtonPositions: assetConfig.uiButtonPositions,
      uiButtonsVisibility: assetConfig.uiButtonsVisibility,
      extractedUIButtons: assetConfig.extractedUIButtons,
      // Win display image for big win / splash
      winDisplayImage: assetConfig.winDisplayImage,
      winDisplayPositions: assetConfig.winDisplayPositions,
      winDisplayScales: assetConfig.winDisplayScales,
      logo: assetConfig.logoPath,
      logoPositions: assetConfig.logoPositions,
      logoScales: assetConfig.logoScales,
      currentDevice: assetConfig.currentDevice,
      // Legacy compatibility
      logoPosition: assetConfig.logoPositions[assetConfig.currentDevice],
      logoScale: assetConfig.logoScales[assetConfig.currentDevice],
      // Never sync showSymbolGrid to prevent automatic changes
      gridPosition: assetConfig.gridPosition,
      gridScale: assetConfig.gridScale,
      gridStretch: assetConfig.gridStretch
    });

    // Save to API whenever assets are updated
    const gameId = config.gameId;
    if (gameId && (assetConfig.backgroundPath || assetConfig.framePath || assetConfig.logoPath || assetConfig.uiElements.spinButton)) {
      // Debounce API calls to avoid too many requests
      const timeoutId = setTimeout(async () => {
        try {
          const gameStoreData = useGameStore.getState().config;
          await slotApiClient.saveGameConfig(gameId, gameStoreData);
        } catch (error) {
          console.error('Failed to save assets config to API:', error);
        }
      }, 1000); // 1 second debounce

      return () => clearTimeout(timeoutId);
    }

    // If we have a background, emit event for preview
    if (assetConfig.backgroundPath) {
      window.dispatchEvent(new CustomEvent('backgroundUpdated', {
        detail: {
          backgroundUrl: assetConfig.backgroundPath,
          position: assetConfig.backgroundPosition,
          scale: assetConfig.backgroundScale,
          fit: assetConfig.backgroundFit
        }
      }));
    }
  }, [assetConfig]);

  // Listen for logo position changes from preview
  useEffect(() => {
    const handleLogoPositionChange = (event: CustomEvent) => {
      const { position, device } = event.detail;

      // Update position for the specific device
      const newPositions = {
        ...assetConfig.logoPositions,
        [device]: position
      };
      updateAssetConfig('logoPositions', newPositions);
    };

    const handleLogoScaleChange = (event: CustomEvent) => {
      const { scale, device } = event.detail;

      // Update scale for the specific device
      const newScales = {
        ...assetConfig.logoScales,
        [device]: scale
      };
      updateAssetConfig('logoScales', newScales);
    };

    window.addEventListener('logoPositionChanged', handleLogoPositionChange as EventListener);
    window.addEventListener('logoScaleChanged', handleLogoScaleChange as EventListener);
    return () => {
      window.removeEventListener('logoPositionChanged', handleLogoPositionChange as EventListener);
      window.removeEventListener('logoScaleChanged', handleLogoScaleChange as EventListener);
    };
  }, [assetConfig.logoPositions, assetConfig.logoScales]);

  // Listen for winDisplay position changes from preview
  useEffect(() => {
    const handleWinDisplayPositionChange = (event: CustomEvent) => {
      const { position, device } = event.detail;

      // Update position for the specific device
      const newPositions = {
        ...assetConfig.winDisplayPositions,
        [device]: position
      };
      updateAssetConfig('winDisplayPositions', newPositions);
    };

    const handleWinDisplayScaleChange = (event: CustomEvent) => {
      const { scale, device } = event.detail;

      // Update scale for the specific device
      const newScales = {
        ...assetConfig.winDisplayScales,
        [device]: scale
      };
      updateAssetConfig('winDisplayScales', newScales);
    };

    window.addEventListener('winDisplayPositionChanged', handleWinDisplayPositionChange as EventListener);
    window.addEventListener('winDisplayScaleChanged', handleWinDisplayScaleChange as EventListener);
    return () => {
      window.removeEventListener('winDisplayPositionChanged', handleWinDisplayPositionChange as EventListener);
      window.removeEventListener('winDisplayScaleChanged', handleWinDisplayScaleChange as EventListener);
    };
  }, [assetConfig.winDisplayPositions, assetConfig.winDisplayScales]);

  // Dispatch initial grid adjustments on mount and when grid values change
  useEffect(() => {
    const gridAdjustments = {
      position: assetConfig.gridPosition,
      scale: assetConfig.gridScale,
      stretch: assetConfig.gridStretch,
      showSymbolGrid: assetConfig.showSymbolGrid
    };

    window.dispatchEvent(new CustomEvent('gridAdjustmentsUpdated', {
      detail: gridAdjustments
    }));
  }, [assetConfig.gridPosition, assetConfig.gridScale, assetConfig.gridStretch, assetConfig.showSymbolGrid]);

  // Dispatch initial frame adjustments on mount and when frame values change
  useEffect(() => {
    const frameAdjustments = {
      position: assetConfig.framePosition,
      scale: assetConfig.frameScale,
      stretch: assetConfig.frameStretch
    };

    window.dispatchEvent(new CustomEvent('frameAdjustmentsUpdated', {
      detail: frameAdjustments
    }));
  }, [assetConfig.framePosition, assetConfig.frameScale, assetConfig.frameStretch]);

  // Dispatch initial background adjustments on mount and when background values change
  useEffect(() => {
    const backgroundAdjustments = {
      position: assetConfig.backgroundPosition,
      scale: assetConfig.backgroundScale,
      fit: assetConfig.backgroundFit,
      backgroundUrl: assetConfig.backgroundPath
    };

    window.dispatchEvent(new CustomEvent('backgroundAdjustmentsUpdated', {
      detail: backgroundAdjustments
    }));
  }, [assetConfig.backgroundPosition, assetConfig.backgroundScale, assetConfig.backgroundFit, assetConfig.backgroundPath]);



  // Update a specific asset config property
  const updateAssetConfig = (property: keyof AssetConfig, value: any) => {

    setAssetConfig(prev => ({
      ...prev,
      [property]: value
    }));

    // Dispatch events for PixiJS integration when asset paths are updated
    if (value && typeof value === 'string') {
      switch (property) {
        case 'framePath':
          window.dispatchEvent(new CustomEvent('frameUpdated', {
            detail: { frameUrl: value, frameStyle: assetConfig.frameStyle }
          }));
          break;
        case 'frameStyle':
          window.dispatchEvent(new CustomEvent('frameUpdated', {
            detail: { frameUrl: assetConfig.framePath, frameStyle: value }
          }));
          break;
        case 'logoPath':
          window.dispatchEvent(new CustomEvent('logoUpdated', {
            detail: { logoUrl: value }
          }));
          break;
        case 'winDisplayImage':
          window.dispatchEvent(new CustomEvent('winDisplayUpdated', {
            detail: { winDisplayUrl: value }
          }));
          break;
        case 'uiButtonsPath':
          window.dispatchEvent(new CustomEvent('uiButtonsUpdated', {
            detail: { uiButtonsUrl: value }
          }));
          break;
      }
    }

    // Dispatch grid adjustment events
    if (property === 'gridPosition' || property === 'gridScale' || property === 'gridStretch' || property === 'showSymbolGrid') {
      // Get the current state to build the complete grid adjustments object
      const currentConfig = assetConfig;
      const gridAdjustments = {
        position: property === 'gridPosition' ? value : currentConfig.gridPosition,
        scale: property === 'gridScale' ? value : currentConfig.gridScale,
        stretch: property === 'gridStretch' ? value : currentConfig.gridStretch,
        showSymbolGrid: property === 'showSymbolGrid' ? value : currentConfig.showSymbolGrid
      };

      window.dispatchEvent(new CustomEvent('gridAdjustmentsUpdated', {
        detail: gridAdjustments
      }));
    }

    // Dispatch frame adjustment events
    if (property === 'framePosition' || property === 'frameScale' || property === 'frameStretch') {
      // Get the current state to build the complete frame adjustments object
      const currentConfig = assetConfig;
      const frameAdjustments = {
        position: property === 'framePosition' ? value : currentConfig.framePosition,
        scale: property === 'frameScale' ? value : currentConfig.frameScale,
        stretch: property === 'frameStretch' ? value : currentConfig.frameStretch
      };

      window.dispatchEvent(new CustomEvent('frameAdjustmentsUpdated', {
        detail: frameAdjustments
      }));
    }

    // Dispatch reel gap adjustment events
    if (property === 'reelGap' || property === 'reelDividerPosition' || property === 'reelDividerStretch') {
      const currentConfig = assetConfig;
      const reelGapAdjustments = {
        gap: property === 'reelGap' ? value : currentConfig.reelGap,
        position: property === 'reelDividerPosition' ? value : currentConfig.reelDividerPosition,
        stretch: property === 'reelDividerStretch' ? value : currentConfig.reelDividerStretch,
        updateType: 'reel-adjustment' // Indicate this is a reel adjustment, not full refresh
      };

      window.dispatchEvent(new CustomEvent('reelGapAdjustmentsUpdated', {
        detail: reelGapAdjustments
      }));
    }

    // Dispatch UI button adjustment events
    if (property === 'uiButtonsPosition' || property === 'uiButtonsScale' || property === 'uiButtonsVisibility' || property === 'uiButtonScales' || property === 'uiButtonPositions') {
      // Get the current state to build the complete UI button adjustments object
      const currentConfig = assetConfig;
      const uiButtonAdjustments = {
        position: property === 'uiButtonsPosition' ? value : currentConfig.uiButtonsPosition,
        scale: property === 'uiButtonsScale' ? value : currentConfig.uiButtonsScale,
        buttonScales: property === 'uiButtonScales' ? value : (currentConfig.uiButtonScales || {}),
        buttonPositions: property === 'uiButtonPositions' ? value : (currentConfig.uiButtonPositions || {}),
        visibility: property === 'uiButtonsVisibility' ? value : currentConfig.uiButtonsVisibility
      };

      window.dispatchEvent(new CustomEvent('uiButtonAdjustmentsUpdated', {
        detail: uiButtonAdjustments
      }));
    }

    // Also dispatch for individual button paths
    if (property === 'extractedUIButtons' && value) {
      window.dispatchEvent(new CustomEvent('individualButtonsUpdated', {
        detail: { buttons: value }
      }));
    }

    // Dispatch background positioning events for PixiJS integration
    if (property === 'backgroundPosition' || property === 'backgroundScale' || property === 'backgroundFit') {
      const currentConfig = assetConfig;
      const backgroundAdjustments = {
        position: property === 'backgroundPosition' ? value : currentConfig.backgroundPosition,
        scale: property === 'backgroundScale' ? value : currentConfig.backgroundScale,
        fit: property === 'backgroundFit' ? value : currentConfig.backgroundFit,
        backgroundUrl: currentConfig.backgroundPath
      };


      window.dispatchEvent(new CustomEvent('backgroundAdjustmentsUpdated', {
        detail: backgroundAdjustments
      }));

      // Also update the game store for persistence
      updateConfig({
        backgroundPosition: backgroundAdjustments.position,
        backgroundScale: backgroundAdjustments.scale,
        backgroundFit: backgroundAdjustments.fit
      });
    }

    // Dispatch logo positioning and scaling events
    if (property === 'logoPositions' || property === 'logoScales') {
      const currentConfig = assetConfig;
      if (property === 'logoPositions') {
        window.dispatchEvent(new CustomEvent('logoPositionChanged', {
          detail: {
            position: value[currentConfig.currentDevice],
            device: currentConfig.currentDevice
          }
        }));
      } else if (property === 'logoScales') {
        window.dispatchEvent(new CustomEvent('logoScaleChanged', {
          detail: {
            scale: value[currentConfig.currentDevice],
            device: currentConfig.currentDevice
          }
        }));
      }
    }
  };

  // Generate background using AI
  const generateBackground = async () => {
    // Set generating state
    updateAssetConfig('isGeneratingBackground', true);

    try {
      // Get current grid and device info
      const reels = config.reels?.layout?.reels || 5;
      const rows = config.reels?.layout?.rows || 3;

      // Get theme name - handle both string and object formats
      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || config.theme?.name || 'casino');

      const basePrompt = assetConfig.backgroundPrompt.trim() ||
        `A beautiful slot machine background for a ${themeName} theme`;

      // Enhanced prompt with size specifications
      const enhancedPrompt = `Create a breathtaking slot machine game background for a ${themeName} themed casino game.
        
        THEME & ATMOSPHERE:
        ${basePrompt}
        - Capture the essence of ${themeName} with rich environmental details
        - Create immersive atmosphere with appropriate lighting and mood
        - Include subtle animated elements suggestions (particles, glows, ambient effects)
        
        VISUAL COMPOSITION:
        - Optimized for a ${reels}x${rows} slot grid in the center
        - Darker or softly blurred areas where the slot grid will be placed
        - More detailed and vibrant elements around the edges
        - Depth and layering to create visual interest
        - Balanced composition that draws focus to center
        
        TECHNICAL REQUIREMENTS:
        - Ultra high quality, ${themeName.includes('cartoon') || themeName.includes('candy') ? 'stylized art style' : 'photorealistic rendering'}
        - Rich color palette appropriate for ${themeName} theme
        - Professional casino game aesthetic
        - 1024x1024 resolution (will be scaled for different devices)
        - Suitable for both landscape (16:9) and portrait (9:16) cropping
        
        IMPORTANT DETAILS:
        - No UI elements, buttons, or text
        - No slot reels or symbols (just background)
        - Subtle vignetting to frame the composition
        - High contrast between background and where symbols will appear
        - Premium, polished look that enhances player experience
        
        Create a stunning background that transports players into the ${themeName} world!`;

      // Generate background using GPT-image-1 with proper response ID tracking
      const result = await enhancedOpenaiClient.generateImageWithConfig({
        prompt: enhancedPrompt,
        targetSymbolId: 'background_main', // Store response ID under this identifier
        gameId: config.gameId,
        count: 1
      });

      // Update the background path with the generated image
      if (result && result.success && result.images && result.images.length > 0) {
        const imageUrl = result.images[0];

        updateAssetConfig('backgroundPath', imageUrl);

        // Save to API with gameStore data
        const gameId = config.gameId || `${config.theme?.name || 'slot'}_${new Date().toISOString().split('T')[0]}`.toLowerCase().replace(/[^a-z0-9]/g, '_');
        if (gameId) {
          try {
            const gameStoreData = useGameStore.getState().config;
            await slotApiClient.saveGameConfig(gameId, gameStoreData);
          } catch (error) {
            console.error('Failed to save background config to API:', error);
          }
        }

        // Store the response ID for multi-turn derivations
        if (result.responseId) {
          updateAssetConfig('backgroundResponseId', result.responseId);
        } else {
          console.warn('No response ID found in main background generation result');
          // The response ID should be automatically stored by generateImageWithConfig under 'background_main'
        }

        // Emit event for UnifiedSlotPreview
        window.dispatchEvent(new CustomEvent('backgroundUpdated', {
          detail: {
            backgroundUrl: imageUrl,
            position: assetConfig.backgroundPosition,
            scale: assetConfig.backgroundScale,
            fit: assetConfig.backgroundFit
          }
        }));
        showSuccess('Success', 'Background generated successfully!');
      }
    } catch (error) {
      console.error('Error generating background:', error);
      showWarning('Error', 'Failed to generate background. Please try again or upload an image.');
    } finally {
      updateAssetConfig('isGeneratingBackground', false);
    }
  };

  // Generate win display (big win / splash)
  const generateWinDisplay = async () => {
    updateAssetConfig('isGeneratingWinDisplay', true);

    try {
      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || config.theme?.name || 'casino');

      const basePrompt = assetConfig.winDisplayPrompt?.trim() || `A splash for a ${themeName} themed slot game`;

      const enhancedPrompt = `Create a high-energy WIN Amount DISPLAY  for a ${themeName} themed slot machine game.\n\n${basePrompt}\n\n- PNG with transparency where appropriate\n- High resolution suitable for desktop and mobile`;

      const result = await enhancedOpenaiClient.generateImageWithConfig({
        prompt: enhancedPrompt,
        targetSymbolId: 'win_display_main',
        gameId: config.gameId,
        count: 1
      });

      if (result && result.success && result.images && result.images.length > 0) {
        const imageUrl = result.images[0];

        // Update local asset config and global store
        updateAssetConfig('winDisplayImage', imageUrl);
        updateConfig({ winDisplayImage: imageUrl });

        // Save to API with gameStore data
        const gameId = config.gameId || `${themeName || 'slot'}_${new Date().toISOString().split('T')[0]}`.toLowerCase().replace(/[^a-z0-9]/g, '_');
        if (gameId) {
          try {
            const gameStoreData = useGameStore.getState().config;
            await slotApiClient.saveGameConfig(gameId, gameStoreData);
          } catch (error) {
            console.error('Failed to save win display config to API:', error);
          }
        }

        // Emit preview event
        window.dispatchEvent(new CustomEvent('winDisplayUpdated', {
          detail: { winDisplayUrl: imageUrl }
        }));

        showSuccess('Success', 'Win display generated successfully!');
      } else {
        showWarning('Error', 'Failed to generate win display image. Please try again.');
      }
    } catch (error) {
      console.error('Error generating win display:', error);
      showWarning('Error', 'Failed to generate win display. Please try again.');
    } finally {
      updateAssetConfig('isGeneratingWinDisplay', false);
    }
  };

  // Handle win display image upload
  const handleWinDisplayUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      return;
    }

    const file = files[0];

    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      if (event.target && typeof event.target.result === 'string') {
        updateAssetConfig('winDisplayImage', event.target.result);

        // Save immediately to global store
        updateConfig({ winDisplayImage: event.target.result });

        // Emit preview event
        window.dispatchEvent(new CustomEvent('winDisplayUpdated', {
          detail: { winDisplayUrl: event.target.result }
        }));
      }
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      alert('Failed to read the image file');
    };

    reader.readAsDataURL(file);
  };

  // Set background variation in PixiJS preview (preview only, don't change main background)
  const setBackgroundInPreview = (backgroundUrl: string, variationType: string) => {
    // Only dispatch event to update PixiJS preview, don't change main background
    const event = new CustomEvent('backgroundUpdated', {
      detail: {
        backgroundUrl: backgroundUrl,
        variationType: variationType,
        previewOnly: true // Flag to indicate this is preview only
      }
    });
    window.dispatchEvent(event);
  };

  // Derive background variations for different game modes
  const deriveBackground = async (variationType: 'night' | 'day' | 'bonus' | 'freespin') => {
    if (!assetConfig.backgroundPath) {
      showWarning('Warning', 'Please generate or upload a base background first before creating variations.');
      return;
    }

    updateAssetConfig('isDeriving', true);
    updateAssetConfig('derivingType', variationType);

    try {
      // Get theme name
      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || config.theme?.name || 'casino');

      // Custom derive prompt or auto-generate based on variation type
      const customPrompt = assetConfig.derivePrompt.trim();

      // Get the original background prompt that was used to generate the main background
      const originalBackgroundPrompt = assetConfig.backgroundPrompt.trim();

      // Create variation-specific transformation instructions
      const variationTransformations = {
        night: 'Transform this into a nighttime version with darker atmosphere, moonlight, stars, glowing elements, and mysterious ambiance. Keep the same composition and theme but shift to nocturnal mood.',
        day: 'Transform this into a bright daytime version with sunlight, clear skies, vibrant colors, and energetic atmosphere. Keep the same composition and theme but shift to bright, cheerful mood.',
        bonus: 'Transform this into an exciting bonus round version with enhanced magical effects, golden particles, energy bursts, dramatic lighting, and celebratory atmosphere. Keep the same composition but make it more spectacular.',
        freespin: 'Transform this into a special free spins version with mystical enhancements, ethereal glowing effects, special particle systems, enchanted atmosphere, and premium feel. Keep the same composition but add magical elements.'
      };

      // Use custom prompt if provided, otherwise use original background prompt with variation transformation
      const basePrompt = customPrompt ||
        (originalBackgroundPrompt
          ? `${originalBackgroundPrompt} - ${variationTransformations[variationType]}`
          : `A ${themeName} themed slot machine background - ${variationTransformations[variationType]}`);

      // Enhanced prompt for background variation emphasizing composition preservation
      const enhancedPrompt = `Transform the provided source image into a ${variationType} variation. Use the exact same scene composition with only lighting and atmospheric changes.

        CRITICAL: This is an IMAGE-TO-IMAGE transformation of the provided source background image.
        ${originalBackgroundPrompt ? `\nORIGINAL SCENE DESCRIPTION: ${originalBackgroundPrompt}` : ''}

        PRESERVE EXACTLY FROM SOURCE IMAGE:
        - All building/structure positions and shapes
        - All architectural elements and their placement
        - Tree positions and landscape layout
        - Horizon line and perspective angle
        - Foreground and background element placement
        - All environmental and architectural details
        - Overall composition and spatial relationships
        - Center area clear space for slot grid

        TRANSFORMATION FOR ${variationType.toUpperCase()}:
        ${basePrompt}
        
        LIGHTING AND ATMOSPHERE CHANGES ONLY:
        ${variationType === 'night' ? `
        - TIME: Nighttime with moonlight as primary light source
        - SKY: Dark night sky with stars, moon, or aurora
        - LIGHTING: Cool moonlight, glowing windows/lanterns
        - COLORS: Deep blues, purples, silvers, cool tones
        - MOOD: Mysterious, peaceful, enchanting nighttime` : ''}
        ${variationType === 'day' ? `
        - TIME: Bright daytime with sunlight as primary light source
        - SKY: Bright blue sky with white fluffy clouds
        - LIGHTING: Natural daylight, no artificial lights needed
        - COLORS: Warm golds, yellows, vibrant bright colors
        - MOOD: Energetic, cheerful, inviting daytime` : ''}
        ${variationType === 'bonus' ? `
        - ENHANCEMENT: Magical bonus effects overlay
        - LIGHTING: Dramatic golden spotlights and energy beams
        - EFFECTS: Floating gold particles, sparkles, gem glints
        - COLORS: Rich golds, oranges, jewel tones
        - MOOD: Celebratory, rewarding, spectacular` : ''}
        ${variationType === 'freespin' ? `
        - ENHANCEMENT: Mystical supernatural effects overlay
        - LIGHTING: Ethereal glows and magical illumination
        - EFFECTS: Floating particles, energy wisps, halos
        - COLORS: Mystical purples, silvers, magical blues
        - MOOD: Enchanted, otherworldly, mystical` : ''}
        
        STRICT PRESERVATION RULES:
        - Same architectural elements in exact same positions
        - Same perspective and viewpoint angle
        - Same composition and spatial relationships
        - Same level of detail and visual complexity
        - Same ${themeName} theme visual identity
        - Same center area optimization for slot grid
        - Only change: time of day, lighting, and atmospheric effects
        
        Create a ${variationType} version that looks like the exact same location photographed under different conditions!`;

      // Generate background variation using the enhanced prompt
      const result = await enhancedOpenaiClient.generateImageWithConfig({
        prompt: enhancedPrompt,
        sourceImage: assetConfig.backgroundPath,
        sourceDescription: `${themeName} themed slot machine background`,
        sourceSymbolId: 'background_main', // Look up response ID for main background
        targetSymbolId: `background_${variationType}`, // Store new response ID for this variation
        gameId: config.gameId,
        count: 1
      });

      if (result && result.success && result.images && result.images.length > 0) {
        const imageUrl = result.images[0];

        // Update the derived backgrounds
        const newDerivedBackgrounds = {
          ...assetConfig.derivedBackgrounds,
          [variationType]: imageUrl
        };
        updateAssetConfig('derivedBackgrounds', newDerivedBackgrounds);

        // Save to API with gameStore data
        const gameId = config.gameId || `${themeName || 'slot'}_${new Date().toISOString().split('T')[0]}`.toLowerCase().replace(/[^a-z0-9]/g, '_');
        if (gameId) {
          try {
            const gameStoreData = useGameStore.getState().config;
            await slotApiClient.saveGameConfig(gameId, gameStoreData);
          } catch (error) {
            console.error(`Failed to save ${variationType} background config to API:`, error);
          }
        }

        showSuccess('Success', `${variationType.charAt(0).toUpperCase() + variationType.slice(1)} background variation generated successfully!`);
      }
    } catch (error) {
      console.error(`Error generating ${variationType} background:`, error);
      showWarning('Error', `Failed to generate ${variationType} background variation. Please try again.`);
    } finally {
      updateAssetConfig('isDeriving', false);
      updateAssetConfig('derivingType', null);
    }
  };

  // Generate frame using AI
  const generateFrame = async () => {
    // Generate frame for slot game
    updateAssetConfig('isGeneratingFrame', true);

    try {
      // Get theme name - handle both string and object formats
      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || config.theme?.name || 'casino');

      // Get user's style input (just the theme/style part)
      const userFrameStyle = assetConfig.framePrompt.trim() || themeName || 'casino';

      // Get current grid dimensions
      const reels = config.reels?.layout?.reels || 5;
      const rows = config.reels?.layout?.rows || 3;

      // Calculate appropriate frame thickness based on grid size - make frames much smaller
      const isSmallGrid = reels <= 3 && rows <= 3;
      const frameThickness = isSmallGrid ? 'very thin and delicate (maximum 10-15 pixels thick)' : 'thin and elegant (maximum 20-25 pixels thick)';

      // Different prompts based on frame style - reel dividers will be added programmatically
      let styleSpecific = '';
      switch (assetConfig.frameStyle) {
        case 'outer':
          styleSpecific = 'outer border only - no internal dividers';
          break;
        case 'reel':
          styleSpecific = 'no outer border - just a transparent frame (reel dividers will be added programmatically)';
          break;
        case 'both':
          styleSpecific = 'outer border only (reel dividers will be added programmatically for perfect alignment)';
          break;
      }

      // Build the complete prompt with user input embedded
      const enhancedPrompt = `Create a delicate decorative FRAME ONLY for a ${userFrameStyle} themed slot machine game.

        GRID LAYOUT SPECIFICATIONS:
        - This frame is for a ${reels} columns Ã— ${rows} rows slot machine grid
        - Total grid dimensions: ${reels}x${rows} (${reels} reels, ${rows} symbols per reel)
        - ${styleSpecific}

        ESSENTIAL REQUIREMENTS:
        - This is a THIN decorative BORDER/FRAME with a COMPLETELY TRANSPARENT center area
        - The transparent center must occupy 75-80% of the total image area
        - Frame thickness: ${frameThickness} - perfect for a ${reels}x${rows} slot grid
        - Style: Elegant casino quality with ${userFrameStyle} theme decorations
        - IMPORTANT: Keep the frame THIN and DELICATE - it should not dominate the screen

        VISUAL STYLE:
        - Subtle, refined decorative elements matching the ${userFrameStyle} theme
        - Delicate details and textures that don't overwhelm
        - Soft lighting with gentle shadows and highlights
        - Metallic or material-appropriate finishes (gold, wood, crystal, etc.)
        - Symmetrical design for visual balance
        - Minimalist approach - less is more

        TECHNICAL SPECIFICATIONS:
        - Format: PNG with FULL ALPHA TRANSPARENCY in center
        - Resolution: 1024x1024 pixels
        - Color depth: Full color with subtle gradients
        - Anti-aliased edges for smooth appearance
        - NO text, logos, watermarks, or symbols inside the frame
        - Frame should be THIN and ELEGANT, not thick or bulky

        COMPOSITION:
        - Frame elements should be subtle and refined
        - Corner decorations should be small and tasteful
        - Consistent theme throughout all frame elements
        - The frame should complement and enhance, not overpower the slot content
        - Think "elegant border" not "thick frame"

        IMPORTANT NOTE:
        - Reel dividers will be added programmatically for perfect alignment
        - Focus on creating a beautiful ${styleSpecific.includes('border') ? 'border frame' : 'transparent background'}
        - The frame should complement the ${reels}x${rows} grid layout
        - Ensure the transparent center area is perfectly clear for game content

        Create a refined, delicate frame that subtly enhances the slot game experience!`;

      // Generate frame using GPT-image-1
      const result = await enhancedOpenaiClient.generateImage(
        enhancedPrompt,
        {
          size: '1024x1024',
          quality: 'high'
        }
      );

      if (result && result.imageUrl) {
        updateAssetConfig('framePath', result.imageUrl);

        // Save outer frame to theme.generated.frame when frameStyle is 'outer' or 'both'
        if (assetConfig.frameStyle === 'outer' || assetConfig.frameStyle === 'both') {
          updateConfig({
            theme: {
              ...config.theme,
              generated: {
                ...config.theme?.generated,
                frame: result.imageUrl
              }
            }
          });
        }
        showSuccess('Success', 'Frame generated successfully!');
      }
    } catch (error) {
      console.error('Error generating frame:', error);
      showWarning('Error', 'Failed to generate frame. Please try again or upload an image.');
    } finally {
      updateAssetConfig('isGeneratingFrame', false);
    }
  };

  // Generate individual UI buttons one by one for better quality
  const generateIndividualUIButtons = async () => {
    updateAssetConfig('isGeneratingUIButtons', true);


    const customPrompt = assetConfig.uiButtonsPrompt.trim();

    const buttonDefinitions = [
      {
        name: 'spinButton',
        displayName: 'SPIN',
        description: 'Large circular spin button with golden gradient',
        size: '1024x1024',
        targetSize: 120,
        prompt: customPrompt ?
          `${customPrompt} - Create a SPIN button for slot machine games.

DESIGN REQUIREMENTS:
- Medium circular button centered on 1024x1024 canvas
- Bold "SPIN" text clearly visible
- 3D beveled edges with realistic lighting from top-left
- Glossy finish with light reflections and highlights
- Professional casino game aesthetic with premium feel
- High contrast colors for mobile visibility
- Transparent/black background outside the button
- Button should look highly pressable and interactive
- Size: approximately 200-250px diameter on the canvas (medium size)

STYLE: ${customPrompt} themed casino game UI, premium quality, 3D rendered appearance` :
          `Create a premium casino SPIN button for slot machine games.

DESIGN REQUIREMENTS:
- Medium circular button centered on 1024x1024 canvas
- Golden/yellow metallic gradient background with shine effects
- Bold "SPIN" text in white with dramatic drop shadow
- 3D beveled edges with realistic lighting from top-left
- Glossy metallic finish with light reflections and highlights
- Subtle outer glow effect around the button edges
- Professional casino game aesthetic with premium feel
- High contrast colors for mobile visibility
- Transparent/black background outside the button
- Button should look highly pressable and interactive
- Size: approximately 200-250px diameter on the canvas (medium size)

STYLE: Modern casino game UI, premium quality, 3D rendered appearance like real slot machines`
      },
      {
        name: 'autoplayButton',
        displayName: 'AUTO',
        description: 'Auto-play button with blue gradient',
        size: '1024x1024',
        targetSize: 80,
        prompt: customPrompt ?
          `${customPrompt} - Create an AUTO button for slot machine games.

DESIGN REQUIREMENTS:
- Rounded rectangle button centered on 1024x1024 canvas
- "AUTO" text clearly visible
- Small play/pause icons or arrow indicators
- 3D beveled edges with realistic lighting from top-left
- Glossy finish with light reflections and highlights
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look modern and interactive
- Size: approximately 150-180px width on the canvas (small-medium size)

STYLE: ${customPrompt} themed casino game UI, premium quality, 3D rendered appearance` :
          `Create a premium casino AUTO button for slot machine games.

DESIGN REQUIREMENTS:
- Rounded rectangle button centered on 1024x1024 canvas
- Electric blue/cyan metallic gradient with silver accents
- "AUTO" text in bold white with subtle shadow
- Small play/pause icons or arrow indicators
- 3D beveled edges with realistic lighting from top-left
- Glossy finish with light reflections and highlights
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look modern and interactive
- Size: approximately 150-180px width on the canvas (small-medium size)

STYLE: Modern casino game UI, premium quality, 3D rendered appearance like real slot machines`
      },
      {
        name: 'menuButton',
        displayName: 'MENU',
        description: 'Menu button with orange/red gradient',
        size: '1024x1024',
        targetSize: 80,
        prompt: customPrompt ?
          `${customPrompt} - Create a MENU button for slot machine games.

DESIGN REQUIREMENTS:
- Square/rounded rectangle button centered on 1024x1024 canvas
- "MENU" text or hamburger menu icon clearly visible
- 3D beveled edges with realistic lighting from top-left
- Glossy finish with light reflections
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look clickable and modern
- Size: approximately 150-180px width on the canvas (small-medium size)

STYLE: ${customPrompt} themed casino game UI, premium quality, 3D rendered appearance` :
          `Create a premium casino MENU button for slot machine games.

DESIGN REQUIREMENTS:
- Square/rounded rectangle button centered on 1024x1024 canvas
- Orange/red metallic gradient with copper highlights
- "MENU" text or hamburger menu icon in bold white
- 3D beveled edges with realistic lighting from top-left
- Glossy metallic finish with light reflections
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look clickable and modern
- Size: approximately 150-180px width on the canvas (small-medium size)

STYLE: Modern casino game UI, premium quality, 3D rendered appearance like real slot machines`
      },
      {
        name: 'soundButton',
        displayName: 'SOUND',
        description: 'Sound toggle button with speaker icon',
        size: '1024x1024',
        targetSize: 80,
        prompt: customPrompt ?
          `${customPrompt} - Create a SOUND button for slot machine games.

DESIGN REQUIREMENTS:
- Circular button centered on 1024x1024 canvas
- Speaker/sound wave icon clearly visible (no text needed)
- Volume indicator waves or sound symbols around speaker
- 3D beveled edges with realistic lighting from top-left
- Glossy finish with light reflections
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look like a toggle control
- Size: approximately 150-180px diameter on the canvas (small-medium size)

STYLE: ${customPrompt} themed casino game UI, premium quality, 3D rendered appearance` :
          `Create a premium casino SOUND button for slot machine games.

DESIGN REQUIREMENTS:
- Circular button centered on 1024x1024 canvas
- Yellow/gold metallic gradient with bronze accents
- Speaker/sound wave icon in white (no text needed)
- Volume indicator waves or sound symbols around speaker
- 3D beveled edges with realistic lighting from top-left
- Glossy metallic finish with light reflections
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look like a toggle control
- Size: approximately 150-180px diameter on the canvas (small-medium size)

STYLE: Modern casino game UI, premium quality, 3D rendered appearance like real slot machines`
      },
      {
        name: 'settingsButton',
        displayName: 'SETTINGS',
        description: 'Settings button with gear icon',
        size: '1024x1024',
        targetSize: 80,
        prompt: customPrompt ?
          `${customPrompt} - Create a SETTINGS button for slot machine games.

DESIGN REQUIREMENTS:
- Circular button centered on 1024x1024 canvas
- Gear/cog icon clearly visible
- 3D beveled edges with realistic lighting from top-left
- Glossy finish with light reflections
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look professional and subtle
- Size: approximately 150-180px diameter on the canvas (small-medium size)

STYLE: ${customPrompt} themed casino game UI, premium quality, 3D rendered appearance` :
          `Create a premium casino SETTINGS button for slot machine games.

DESIGN REQUIREMENTS:
- Circular button centered on 1024x1024 canvas
- Silver/platinum metallic gradient with chrome highlights
- Gear/cog icon in dark gray or white
- 3D beveled edges with realistic lighting from top-left
- Glossy metallic finish with light reflections
- Professional casino game aesthetic
- Transparent/black background outside the button
- Button should look professional and subtle
- Size: approximately 150-180px diameter on the canvas (small-medium size)

STYLE: Modern casino game UI, premium quality, 3D rendered appearance like real slot machines`
      }
    ];

    const generatedButtons: Record<string, string> = {};
    const buttonImageIds: Record<string, string> = {};
    let successCount = 0;

    // Helper function to crop and resize button from 1024x1024 to target size
    const cropButtonFromImage = async (imageUrl: string, targetSize: number): Promise<string> => {
      return new Promise((resolve, reject) => {
        const img = new window.Image();
        img.crossOrigin = 'anonymous';

        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            reject(new Error('Could not get canvas context'));
            return;
          }

          // Set canvas to target size
          canvas.width = targetSize;
          canvas.height = targetSize;

          // Calculate crop area (center of the 1024x1024 image)
          const sourceSize = 1024;
          const cropSize = Math.min(sourceSize * 0.8, 800); // Use 80% of the image or max 800px
          const cropX = (sourceSize - cropSize) / 2;
          const cropY = (sourceSize - cropSize) / 2;

          // Draw the cropped and resized image
          ctx.drawImage(
            img,
            cropX, cropY, cropSize, cropSize, // Source crop area
            0, 0, targetSize, targetSize       // Destination size
          );

          resolve(canvas.toDataURL('image/png'));
        };

        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = imageUrl;
      });
    };

    try {
      // Import the enhancedOpenaiClient dynamically
      const enhancedOpenaiClient = (await import('../../../utils/enhancedOpenaiClient')).default;

      for (const buttonDef of buttonDefinitions) {
        try {
          const result = await enhancedOpenaiClient.generateImageWithConfig({
            prompt: buttonDef.prompt,
            targetSymbolId: `ui_${buttonDef.name}_normal`,
            gameId: config.gameId,
            count: 1
          });

          if (result?.success && result.images && result.images.length > 0) {
            // Crop the 1024x1024 image to the target size
            const croppedButton = await cropButtonFromImage(result.images[0], buttonDef.targetSize);

            generatedButtons[buttonDef.name] = croppedButton;
            buttonImageIds[buttonDef.name] = `ui_${buttonDef.name}_normal`; // Store the image ID for later use
            successCount++;
          } else {
            console.error(`âŒ [Individual Button] Failed to generate ${buttonDef.displayName}: No image URL`);
          }
        } catch (buttonError) {
          console.error(`âŒ [Individual Button] Error generating ${buttonDef.displayName}:`, buttonError);
        }
      }

      if (successCount > 0) {
        // Update the UI elements with generated buttons
        updateAssetConfig('uiElements', generatedButtons);
        updateAssetConfig('extractedUIButtons', generatedButtons);
        updateAssetConfig('uiButtonImageIds', buttonImageIds); // Store the image IDs

        // Also update the global config
        updateConfig({
          ...(config as any),
          uiElements: generatedButtons,
          extractedUIButtons: generatedButtons,
          uiButtonImageIds: buttonImageIds
        } as any);

        // Save to API with gameStore data
        const gameId = config.gameId;
        if (gameId) {
          try {
            const gameStoreData = useGameStore.getState().config;
            await slotApiClient.saveGameConfig(gameId, gameStoreData);
          } catch (error) {
            console.error('Failed to save UI buttons config to API:', error);
          }
        }
        showSuccess('Success', `Successfully generated ${successCount}/${buttonDefinitions.length} UI buttons!`);

        // Dispatch event to update buttons
        window.dispatchEvent(new CustomEvent('individualButtonsUpdated', {
          detail: { buttons: generatedButtons }
        }));

        // Also dispatch UI button adjustments to ensure buttons are positioned correctly
        setTimeout(() => {
          window.dispatchEvent(new CustomEvent('uiButtonAdjustmentsUpdated', {
            detail: {
              position: assetConfig.uiButtonsPosition,
              scale: assetConfig.uiButtonsScale,
              visibility: assetConfig.uiButtonsVisibility
            }
          }));
        }, 100);
      } else {
        throw new Error('Failed to generate any buttons');
      }

    } catch (error) {
      console.error('ðŸŽ® [Individual Button] Error in individual button generation:', error);

      let errorMessage = 'Failed to generate individual UI buttons. ';

      if (error instanceof Error) {
        if (error.message.includes('timeout') || error.message.includes('TimeoutError')) {
          errorMessage += 'The generation took too long. Please try again.';
        } else if (error.message.includes('rate limit') || error.message.includes('429')) {
          errorMessage += 'Rate limit exceeded. Please wait a moment and try again.';
        } else {
          errorMessage += error.message;
        }
      }

      showWarning('Error', errorMessage);
    } finally {
      updateAssetConfig('isGeneratingUIButtons', false);
    }
  };

  // Original batch generation function (kept as fallback)
  const generateUIButtons = async (retryCount = 0) => {
    updateAssetConfig('isGeneratingUIButtons', true);

    try {
      // Import the enhancedOpenaiClient dynamically to ensure it's available
      const enhancedOpenaiClient = (await import('../../../utils/enhancedOpenaiClient')).default;

      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || 'casino');

      const basePrompt = assetConfig.uiButtonsPrompt.trim() ||
        `UI button set for a ${themeName} slot machine`;

      // Add retry enhancement to prompt if this is a retry
      const retryEnhancement = retryCount > 0 ? `

IMPORTANT: Previous attempt generated gray/monochrome buttons. THIS TIME:
- Use BRIGHT, VIBRANT COLORS for each button
- Make each button VISUALLY DISTINCT with different colors
- Add GLOSSY/METALLIC effects and gradients
- Ensure HIGH CONTRAST between buttons
- NO GRAY OR MONOCHROME BUTTONS!` : '';

      // Generate individual buttons in a grid layout for better extraction
      const enhancedPrompt = `Create 5 individual slot machine UI buttons for ${themeName} theme, arranged in a precise grid for easy extraction.

${basePrompt}

CRITICAL LAYOUT REQUIREMENTS:
- Create a 2x3 grid layout on 1024x1024 canvas
- Top row: MENU (left), SPIN (center), AUTO (right)
- Bottom row: SOUND (left), SETTINGS (right)
- Each button in its own clearly defined 300x300px area
- 100px padding between buttons and from canvas edges
- Pure white background between buttons for clean separation

BUTTON DESIGN SPECIFICATIONS:
1. SPIN button (center-top, 250x250px):
   - Bright gold/green metallic gradient with glow
   - Bold "SPIN" text in white with drop shadow
   - Circular shape with 3D beveled edges
   - Most prominent and eye-catching

2. AUTO button (top-right, 200x200px):
   - Electric blue gradient with silver accents
   - "AUTO" text in white
   - Rounded rectangle with play/pause indicators

3. MENU button (top-left, 200x200px):
   - Orange/red gradient with copper highlights
   - "MENU" text or hamburger icon in white
   - Square with rounded corners

4. SOUND button (bottom-left, 180x180px):
   - Yellow/gold gradient with bronze accents
   - Speaker/sound wave icon in white
   - Circular with volume indicators

5. SETTINGS button (bottom-right, 180x180px):
   - Silver/platinum gradient with chrome finish
   - Gear/cog icon in dark gray
   - Hexagonal or circular shape

STYLE REQUIREMENTS:
- 3D beveled edges with realistic drop shadows
- Glossy metallic finish with light reflections
- High contrast colors for maximum visibility
- Each button should look pressable and interactive
- Consistent lighting from top-left direction
- NO flat or monochrome designs

${retryEnhancement}`;

      // Call the enhanced OpenAI client with progress tracking
      const result = await enhancedOpenaiClient.generateImage(enhancedPrompt, {
        size: '1024x1024',
        quality: 'high'
      });

      if (!result.imageUrl) {
        throw new Error('No image URL returned from generation');
      }

      // Update the UI buttons path
      updateAssetConfig('uiButtonsPath', result.imageUrl);

      // Extract individual buttons from the generated sheet
      try {
        await extractButtonsFromSheet(result.imageUrl);

        // Check if extraction was successful by looking at the updated config
        // Wait a moment for the config to be updated
        setTimeout(() => {
          const currentConfig = useGameStore.getState().config;
          const extractedButtons = (currentConfig as any).uiElements;

          if (extractedButtons && Object.keys(extractedButtons).length > 0) {
            // Store the extracted buttons in our local config for the adjustment system
            updateAssetConfig('extractedUIButtons', extractedButtons);
          } else {
            console.warn('âš ï¸ No buttons were extracted from the sheet');
          }
        }, 500);

      } catch (extractError) {
        console.error('Button extraction error:', extractError);

        // If extraction failed due to color issues, retry generation
        if (extractError instanceof Error && (extractError.message.includes('grayscale') || extractError.message.includes('vibrant colors')) && retryCount < 2) {
          updateAssetConfig('isGeneratingUIButtons', false);
          return generateUIButtons(retryCount + 1);
        }
      }

    } catch (error) {
      console.error('ðŸŽ® [UI Generation] Error generating UI buttons:', error);

      // Provide specific error messages based on error type
      let errorMessage = 'Failed to generate UI buttons. ';

      if (error instanceof Error) {
        if (error.message.includes('timeout') || error.message.includes('TimeoutError')) {
          errorMessage += 'The generation took too long and timed out. This can happen with complex prompts. Please try again with a simpler description or try again later.';
        } else if (error.message.includes('rate limit') || error.message.includes('429')) {
          errorMessage += 'Rate limit exceeded. Please wait a moment and try again.';
        } else if (error.message.includes('network') || error.message.includes('fetch')) {
          errorMessage += 'Network connection issue. Please check your internet connection and try again.';
        } else {
          errorMessage += error.message;
        }
      } else {
        errorMessage += 'Unknown error occurred.';
      }

      // Add helpful suggestions
      errorMessage += '\n\nSuggestions:\nâ€¢ Try a simpler prompt\nâ€¢ Check your internet connection\nâ€¢ Wait a moment and try again\nâ€¢ Upload custom UI button images instead';

      showWarning('Error', errorMessage);
    } finally {
      updateAssetConfig('isGeneratingUIButtons', false);
    }
  };

  // Generate logo using AI
  const generateLogo = async () => {
    updateAssetConfig('isGeneratingLogo', true);

    try {
      // Get theme name - handle both string and object formats
      const themeName = typeof config.theme === 'string'
        ? config.theme
        : (config.theme?.mainTheme || config.theme?.name || 'casino');

      const basePrompt = assetConfig.logoPrompt.trim() ||
        `${themeName} themed slot game logo`;

      // Enhanced prompt for logo generation
      const enhancedPrompt = `Create a professional gaming logo for a ${themeName} themed slot machine game.

        LOGO CONCEPT:
        ${basePrompt}
        - Capture the essence of ${themeName} theme with appropriate symbols and motifs
        - Professional casino/gaming industry aesthetic
        - Memorable and distinctive brand identity
        - Clean, bold design that works at multiple sizes

        VISUAL REQUIREMENTS:
        - High contrast text/symbols that remain readable when scaled down
        - Rich colors appropriate for ${themeName} theme
        - Premium, polished appearance suitable for slot game branding
        - Incorporate relevant thematic elements (crowns, gems, mystical symbols, etc.)
        - Strong visual impact with balanced composition
        - Design should fill most of the canvas area efficiently

        TECHNICAL SPECIFICATIONS:
        - PNG format with transparent background where appropriate
        - Logo should use the full canvas space effectively
        - Bold, clear design elements that are easily readable at small sizes
        - Suitable for use on game interface (top/center positioning)
        - Works well on both dark and light backgrounds
        - Compact, efficient design without wasted space
        - Text should be large and bold if included

        STYLE GUIDELINES:
        - ${themeName.includes('cartoon') || themeName.includes('candy') ? 'Stylized, vibrant art style' : 'Realistic, premium aesthetic'}
        - Typography should be bold and gaming-appropriate
        - Avoid overly complex details that won't scale well
        - Focus on iconic, recognizable elements
        - Make efficient use of the canvas space

        Create a logo that establishes strong brand identity for this ${themeName} slot game!`;

      // Generate logo with GPT-image-1 at a smaller size directly
      const result = await enhancedOpenaiClient.generateImage(
        enhancedPrompt,
        {
          size: '1024x1024', // OpenAI only supports this size, but we'll use it directly without cropping
          quality: 'high'
        }
      );

      if (result && result.imageUrl) {
        // Use the generated logo directly without cropping
        updateAssetConfig('logoPath', result.imageUrl);

        // Save to API with gameStore data
        const gameId = config.gameId || `${config.theme?.name || 'slot'}_${new Date().toISOString().split('T')[0]}`.toLowerCase().replace(/[^a-z0-9]/g, '_');
        if (gameId) {
          try {
            const gameStoreData = useGameStore.getState().config;
            await slotApiClient.saveGameConfig(gameId, gameStoreData);
          } catch (error) {
            console.error('Failed to save logo config to API:', error);
          }
        }
        showSuccess('Success', 'Logo generated successfully!');
      }
    } catch (error) {
      console.error('Error generating logo:', error);
      showWarning('Error', 'Failed to generate logo. Please try again or upload an image.');
    } finally {
      updateAssetConfig('isGeneratingLogo', false);
    }
  };

  // Handle logo image upload
  const handleLogoUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      return;
    }
    const file = files[0];

    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      if (event.target && typeof event.target.result === 'string') {
        updateAssetConfig('logoPath', event.target.result);
      }
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      alert('Failed to read the image file');
    };

    reader.readAsDataURL(file);
  };

  // Handle background image upload
  const handleBackgroundUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      return;
    }

    const file = files[0];

    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      if (event.target && typeof event.target.result === 'string') {
        updateAssetConfig('backgroundPath', event.target.result);

        // Emit event for UnifiedSlotPreview with current adjustments
        window.dispatchEvent(new CustomEvent('backgroundUpdated', {
          detail: {
            backgroundUrl: event.target.result,
            position: assetConfig.backgroundPosition,
            scale: assetConfig.backgroundScale,
            fit: assetConfig.backgroundFit
          }
        }));
      }
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      alert('Failed to read the image file');
    };

    reader.readAsDataURL(file);
  };

  // Handle frame image upload
  const handleFrameUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      return;
    }

    const file = files[0];

    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      if (event.target && typeof event.target.result === 'string') {
        updateAssetConfig('framePath', event.target.result);
      }
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      alert('Failed to read the image file');
    };

    reader.readAsDataURL(file);
  };

  // Handle UI buttons image upload
  const handleUIButtonsUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      return;
    }

    const file = files[0];

    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      if (event.target && typeof event.target.result === 'string') {
        updateAssetConfig('uiButtonsPath', event.target.result);

        // Extract individual buttons from the uploaded image
        extractButtonsFromSheet(event.target.result);
      }
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      alert('Failed to read the image file');
    };

    reader.readAsDataURL(file);
  };

  // Extract individual buttons from a button sheet image using adaptive detection
  const extractButtonsFromSheet = async (imageUrl: string) => {
    try {

      // Create a canvas for extraction
      const img = new window.Image();
      img.crossOrigin = 'anonymous';

      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = imageUrl;
      });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('Could not get canvas context');

      // Set canvas size to match image
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      // Validate that the image has actual content (not just gray)
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      let totalR = 0, totalG = 0, totalB = 0;
      let pixelCount = 0;
      let colorfulPixels = 0;

      // Sample pixels to check for color variation
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];

        if (a > 128) { // Only count non-transparent pixels
          totalR += r;
          totalG += g;
          totalB += b;
          pixelCount++;

          // Check if this pixel has vibrant color (not gray)
          const maxChannel = Math.max(r, g, b);
          const minChannel = Math.min(r, g, b);
          const saturation = maxChannel > 0 ? (maxChannel - minChannel) / maxChannel : 0;

          // Count pixels with good saturation (colorful)
          if (saturation > 0.3) {
            colorfulPixels++;
            hasVibrantColor = true;
          }
        }
      }

      // Calculate percentage of colorful pixels
      const colorfulPercentage = pixelCount > 0 ? (colorfulPixels / pixelCount) * 100 : 0;

      if (pixelCount > 0) {
        const avgR = totalR / pixelCount;
        const avgG = totalG / pixelCount;
        const avgB = totalB / pixelCount;


        // Reject if not enough colorful pixels (less than 20% of the image)
        if (colorfulPercentage < 20) {
          console.warn('Image lacks vibrant colors. Only', colorfulPercentage.toFixed(1) + '% colorful pixels');
          throw new Error('Generated image lacks vibrant colors. Retrying with enhanced prompt.');
        }

        // Also check for grayscale average
        if (Math.abs(avgR - avgG) < 15 && Math.abs(avgG - avgB) < 15 && Math.abs(avgB - avgR) < 15) {
          console.warn('Image average color is grayscale');
          throw new Error('Generated image is grayscale. Retrying with enhanced prompt.');
        }
      }

      // Extract buttons with all states
      const extractedButtons: Record<string, string> = {};
      const extractedButtonsPressed: Record<string, string> = {};
      const extractedButtonsDisabled: Record<string, string> = {};
      let uiBarImage: string | null = null;

      const bottomSectionStart = img.height * 0.8;

      // Extract UI bar first
      const uiBarCanvas = document.createElement('canvas');
      const uiBarCtx = uiBarCanvas.getContext('2d');
      if (uiBarCtx) {
        uiBarCanvas.width = img.width;
        uiBarCanvas.height = 120; // Standard UI bar height

        uiBarCtx.drawImage(
          canvas,
          0, bottomSectionStart,    // Source position
          img.width, 120,           // Source dimensions
          0, 0,                     // Destination position
          img.width, 120            // Destination dimensions
        );

        uiBarImage = uiBarCanvas.toDataURL('image/png');
      }

      // Extract buttons from 2x3 grid layout as specified in the prompt
      // Grid layout: MENU, SPIN, AUTO (top row) | SOUND, SETTINGS (bottom row)
      const buttonLayout = [
        // Top row
        { name: 'menuButton', x: 100, y: 100, size: 200 },      // Top-left
        { name: 'spinButton', x: 400, y: 100, size: 250 },      // Top-center (larger)
        { name: 'autoplayButton', x: 700, y: 100, size: 200 },  // Top-right
        // Bottom row
        { name: 'soundButton', x: 200, y: 500, size: 180 },     // Bottom-left
        { name: 'settingsButton', x: 600, y: 500, size: 180 }   // Bottom-right
      ];

      // Extract each button from its grid position
      for (const button of buttonLayout) {
        const { name, x, y, size } = button
        // Extract normal state
        const normalCanvas = document.createElement('canvas');
        const normalCtx = normalCanvas.getContext('2d');
        if (normalCtx) {
          normalCanvas.width = size;
          normalCanvas.height = size;

          normalCtx.drawImage(
            canvas,
            x, y,           // Source position (exact grid coordinates)
            size, size,     // Source size
            0, 0,           // Dest position
            size, size      // Dest size
          );
          extractedButtons[name] = normalCanvas.toDataURL('image/png');
        }

        // For now, use the same image for pressed and disabled states (will be generated later)
        extractedButtonsPressed[name] = extractedButtons[name];
        extractedButtonsDisabled[name] = extractedButtons[name];
      }
      const buttonMetadata = buttonLayout.reduce((acc, button) => {
        acc[button.name] = {
          shape: button.name === 'spinButton' ? 'circle' : 'rounded',
          width: button.size,
          height: button.size,
          aspectRatio: 1,
          visualWeight: button.name === 'spinButton' ? 0.9 : 0.7,
          position: { x: button.x, y: button.y }
        };
        return acc;
      }, {} as Record<string, any>);

      // Calculate optimal layout for UI
      const layoutConstraints = {
        containerWidth: window.innerWidth > 768 ? Math.min(window.innerWidth, 1200) : window.innerWidth,
        containerHeight: 100, // Increased UI bar height
        minButtonSize: 70,
        maxButtonSize: 120, // Increased max size
        minSpacing: 20,
        spinButtonRatio: 1.4 // Spin button 40% larger than others
      };

      // Create button info for layout calculation using the new button layout
      const buttonInfos = buttonLayout.map((button) => ({
        name: button.name,
        x: button.x,
        y: button.y,
        width: button.size,
        height: button.size,
        shape: button.name === 'spinButton' ? 'circle' as const : 'rounded' as const,
        centerX: button.x + button.size / 2,
        centerY: button.y + button.size / 2,
        aspectRatio: 1,
        visualWeight: button.name === 'spinButton' ? 0.9 : 0.7,
        boundingBox: {
          x: button.x,
          y: button.y,
          width: button.size,
          height: button.size
        }
      }));

      const optimalLayout = adaptiveButtonDetector.calculateOptimalLayout(
        buttonInfos,
        layoutConstraints
      );

      updateAssetConfig('uiElements', extractedButtons);
      updateAssetConfig('uiElementsPressed', extractedButtonsPressed);
      updateAssetConfig('uiElementsDisabled', extractedButtonsDisabled);
      // Force update the global config immediately
      updateConfig({
        ...(config as any),
        uiElements: extractedButtons,
        uiElementsPressed: extractedButtonsPressed,
        uiElementsDisabled: extractedButtonsDisabled,
        uiBar: uiBarImage,
        uiButtonMetadata: buttonMetadata,
        uiButtonLayout: optimalLayout
      } as any);

      // Log to verify the update and force a re-render
      setTimeout(() => {
        // Dispatch a custom event to notify components
        window.dispatchEvent(new CustomEvent('uiButtonsUpdated', {
          detail: {
            buttons: extractedButtons,
            buttonsPressed: extractedButtonsPressed,
            buttonsDisabled: extractedButtonsDisabled,
            uiBar: uiBarImage,
            metadata: buttonMetadata,
            layout: optimalLayout
          }
        }));
      }, 100);

    } catch (error) {
      console.error('Error extracting buttons:', error);
      console.error('Error details:', (error as Error).message, (error as Error).stack);

      // Fallback: use the full image for all buttons
      const fallbackButtons = {
        spinButton: imageUrl,
        autoplayButton: imageUrl,
        menuButton: imageUrl,
        soundButton: imageUrl,
        settingsButton: imageUrl
      };

      updateAssetConfig('uiElements', fallbackButtons);
    }
  };

  // Auto-adjust frame based on grid layout
  const autoAdjustFrame = () => {
    const reels = config.reels?.layout?.reels || 5;
    const rows = config.reels?.layout?.rows || 3;

    const gridDensity = reels * rows;
    const aspectRatio = reels / rows;
    const isWideGrid = aspectRatio > 1.8;
    const isTallGrid = aspectRatio < 1.2;
    const isSquareGrid = reels === rows;

    let newScale = 100;
    let newPosition = { x: 0, y: 0 };
    let newStretch = { x: 100, y: 100 };

    // Apply appropriate adjustments based on grid type
    if (gridDensity <= 12) {
      if (isSquareGrid) {
        // 3x3 square grid
        newScale = 115;
        newPosition = { x: 0, y: -5 };
      } else if (isWideGrid) {
        // 4x3 grid
        newScale = 110;
        newStretch = { x: 102, y: 100 };
      }
    } else if (gridDensity <= 20) {
      if (isWideGrid) {
        // 5x3, 6x3, 7x3 grids
        newScale = 105;
        newStretch = { x: Math.min(105, 100 + (reels - 5) * 2), y: 100 };
      } else if (isTallGrid) {
        // 3x5, 3x6 grids
        newScale = 105;
        newStretch = { x: 100, y: Math.min(105, 100 + (rows - 3) * 2) };
      } else {
        // Standard 5x3 grid
        newScale = 100;
        newStretch = { x: 100, y: 100 };
      }
    } else {
      // Large grids
      newScale = Math.max(90, 100 - Math.floor(gridDensity / 10) * 2);
      newStretch = {
        x: Math.min(115, 100 + (reels - 5) * 3),
        y: Math.min(115, 100 + (rows - 3) * 3)
      };
    }

    updateAssetConfig('frameScale', newScale);
    updateAssetConfig('framePosition', newPosition);
    updateAssetConfig('frameStretch', newStretch);

  };

  // Apply frame template based on grid type
  const applyFrameTemplate = async (templateType: 'minimal' | 'ornate' | 'reels' | 'adaptive') => {
    setGridOptimize(templateType);
    const reels = config.reels?.layout?.reels;
    const rows = config.reels?.layout?.rows;
    const themeName = typeof config.theme === 'string'
      ? config.theme
      : (config.theme?.mainTheme || config.theme?.name || 'casino');

    let templatePrompt = '';
    let frameStyle: 'outer' | 'reel' | 'both' = 'outer';

    switch (templateType) {
      case 'minimal':
        frameStyle = 'outer';
        templatePrompt = `Minimal, clean frame for ${themeName} slot machine. Simple elegant border with subtle ${themeName} theme elements. Very thin frame (30-40 pixels) perfect for ${reels}x${rows} grid.`;
        break;

      case 'ornate':
        frameStyle = 'outer';
        templatePrompt = `Highly decorative, ornate frame for premium ${themeName} slot machine. Rich detailed borders with intricate ${themeName} themed ornaments, corners, and embellishments. Luxurious casino-quality frame for ${reels}x${rows} grid.`;
        break;

      case 'reels':
        frameStyle = 'reel';
        templatePrompt = `Reel separator frame for ${themeName} slot machine. Vertical dividers between reels with ${themeName} themed decorative elements. Perfect reel separation for ${reels}x${rows} grid layout.`;
        break;

      case 'adaptive':
        frameStyle = 'both';
        templatePrompt = `Smart adaptive frame for ${themeName} slot machine. Automatically optimized design for ${reels}x${rows} grid with perfect proportions. Includes both outer border and reel dividers with balanced ${themeName} themed styling.`;
        autoAdjustFrame(); // Auto-adjust positioning
        break;

      default:
        frameStyle = 'outer';
        templatePrompt = `Minimal, clean frame for ${themeName} slot machine. Simple elegant border with subtle ${themeName} theme elements. Very thin frame (30-40 pixels) perfect for ${reels}x${rows} grid.`;
        break;
    }


    // Update frame configuration
    updateAssetConfig('frameStyle', frameStyle);
    updateAssetConfig('framePrompt', templatePrompt);

    // Apply template-specific positioning
    switch (templateType) {
      case 'minimal':
        updateAssetConfig('frameScale', 105);
        updateAssetConfig('framePosition', { x: 0, y: 0 });
        updateAssetConfig('frameStretch', { x: 100, y: 100 });
        break;

      case 'ornate':
        updateAssetConfig('frameScale', 110);
        updateAssetConfig('framePosition', { x: 0, y: -2 });
        updateAssetConfig('frameStretch', { x: 102, y: 102 });
        break;

      case 'reels':
        updateAssetConfig('frameScale', 100);
        updateAssetConfig('framePosition', { x: 0, y: 0 });
        updateAssetConfig('frameStretch', { x: 98, y: 100 });
        break;
    }
  };

  // Validate frame quality and transparency
  const validateFrame = async (frameUrl: string) => {
    try {

      // Create image element to analyze
      const img = new Image();
      img.crossOrigin = 'anonymous';

      return new Promise((resolve, reject) => {
        img.onload = () => {
          // Create canvas for analysis
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            reject(new Error('Could not create canvas context'));
            return;
          }

          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          // Analyze transparency in center area
          const centerX = img.width / 2;
          const centerY = img.height / 2;
          const centerWidth = img.width * 0.6; // Check 60% of center area
          const centerHeight = img.height * 0.6;

          const imageData = ctx.getImageData(
            centerX - centerWidth / 2,
            centerY - centerHeight / 2,
            centerWidth,
            centerHeight
          );

          let transparentPixels = 0;
          let totalPixels = imageData.data.length / 4;

          // Check alpha channel
          for (let i = 3; i < imageData.data.length; i += 4) {
            if (imageData.data[i] < 50) { // Alpha < 50 is considered transparent
              transparentPixels++;
            }
          }

          const transparencyPercentage = (transparentPixels / totalPixels) * 100;

          // Validation results
          const validation = {
            isValid: transparencyPercentage > 60, // At least 60% transparent center
            transparencyPercentage: Math.round(transparencyPercentage),
            dimensions: { width: img.width, height: img.height },
            gridCompatibility: true, // Always true for generated frames
            recommendations: []
          };

          if (validation.transparencyPercentage < 60) {
            validation.recommendations.push('Frame center should be more transparent for better symbol visibility');
          }
          if (img.width !== img.height) {
            validation.recommendations.push('Square aspect ratio (1:1) recommended for optimal grid alignment');
          }
          if (img.width < 512) {
            validation.recommendations.push('Higher resolution (1024x1024) recommended for crisp details');
          }


          // Show validation results to user
          const statusMessage = validation.isValid
            ? `âœ… Frame validated! ${validation.transparencyPercentage}% center transparency`
            : `âš ï¸ Frame needs improvement: ${validation.recommendations.join(', ')}`;

          showSuccess('Frame Validation', statusMessage);
          resolve(validation);
        };

        img.onerror = () => {
          reject(new Error('Failed to load frame image for validation'));
        };

        img.src = frameUrl;
      });

    } catch (error) {
      console.error('Frame validation error:', error);
      showWarning('Error', 'Failed to validate frame. Please try again.');
    }
  };

  // Generate device-specific background versions
  const generateDeviceSpecificBackgrounds = async () => {
    if (!assetConfig.backgroundPath) {
      showWarning('Warning', 'Please generate or upload a main background first');
      return;
    }

    try {
      updateAssetConfig('isDeriving', true);

      const devices = [
        { name: 'desktop', ratio: '16:9', description: 'Desktop widescreen' },
        { name: 'mobile-portrait', ratio: '9:16', description: 'Mobile portrait' },
        { name: 'mobile-landscape', ratio: '16:9', description: 'Mobile landscape' }
      ];

      for (const device of devices) {
        const enhancedOpenaiClient = (await import('../../../utils/enhancedOpenaiClient')).default;

        // Get the original background prompt for better context
        const originalPrompt = assetConfig.backgroundPrompt.trim();
        const sourceDescription = originalPrompt || `Slot machine background`;

        const result = await enhancedOpenaiClient.generateImageWithConfig({
          sourceImage: assetConfig.backgroundPath,
          sourceDescription: sourceDescription,
          sourceSymbolId: 'background_main',
          targetSymbolId: `background_${device.name}`,
          gameId: config.gameId,
          count: 1,
          additionalPrompt: `Optimize this background for ${device.description} (${device.ratio} aspect ratio). Ensure all important visual elements are visible and properly composed for ${device.name} viewing.`
        });

        if (result && result.success && result.images && result.images.length > 0) {
          // Save to derived backgrounds
          const newDerivedBackgrounds = {
            ...assetConfig.derivedBackgrounds,
            [device.name]: result.images[0]
          };
          updateAssetConfig('derivedBackgrounds', newDerivedBackgrounds);
        }
      }

      showSuccess('Success', 'Device-specific backgrounds generated successfully!');
    } catch (error) {
      console.error('Error generating device-specific backgrounds:', error);
      showWarning('Error', 'Failed to generate device-specific backgrounds. Please try again.');
    } finally {
      updateAssetConfig('isDeriving', false);
    }
  };

  // Regenerate missing button states (pressed and disabled)
  const regenerateButtonStates = async () => {
    try {
      const buttonNames = ['spinButton', 'autoplayButton', 'menuButton', 'soundButton', 'settingsButton'];
      const missingStates = [];

      // Check which buttons need pressed or disabled states
      for (const buttonName of buttonNames) {
        if (assetConfig.uiElements[buttonName] && assetConfig.uiButtonImageIds?.[buttonName]) {
          if (!assetConfig.uiElementsPressed?.[buttonName]) {
            missingStates.push({ button: buttonName, state: 'pressed' });
          }
          if (!assetConfig.uiElementsDisabled?.[buttonName]) {
            missingStates.push({ button: buttonName, state: 'disabled' });
          }
        } else {
          console.log(`âš ï¸ Skipping ${buttonName} - no normal state or image ID found`);
        }
      }

      if (missingStates.length === 0) {
        showSuccess('Info', 'All button states are already generated!');
        return;
      }
      missingStates.map(s => `${s.button} (${s.state})`).join(', ');

      updateAssetConfig('isGeneratingButtonStates', true);

      const { enhancedOpenaiClient } = await import('../../../utils/enhancedOpenaiClient');
      const newPressedButtons = { ...assetConfig.uiElementsPressed };
      const newDisabledButtons = { ...assetConfig.uiElementsDisabled };

      let generatedCount = 0;

      // Generate missing states for each button
      for (const { button, state } of missingStates) {
        try {
          const statePrompts = {
            pressed: `TRANSFORM the provided button image to show a pressed/clicked state. This is an IMAGE-TO-IMAGE transformation:

CRITICAL: Keep the EXACT same button design, text, icons, shape, and layout from the source image.

ONLY change these visual effects:
- Make colors 15-20% darker and less bright
- Add subtle inset shadow to show the button is pressed inward
- Slightly reduce the 3D raised effect (make it look pressed down)
- Keep all text, icons, and design elements in the exact same positions
- Maintain the same button shape, size, and overall appearance
- Only adjust lighting and shadow effects to show pressed state

DO NOT create a new button design. ONLY modify the existing button's lighting and depth effects.`,

            disabled: `TRANSFORM the provided button image to show a disabled/inactive state. This is an IMAGE-TO-IMAGE transformation:

CRITICAL: Keep the EXACT same button design, text, icons, shape, and layout from the source image.

ONLY change these visual effects:
- Reduce color saturation by 60-70% (make colors more gray/muted)
- Reduce overall brightness and contrast by 40-50%
- Keep all text, icons, and design elements in the exact same positions
- Maintain the same button shape, size, and overall appearance
- Make it look faded/muted but still clearly recognizable as the same button
- Should appear non-interactive but professional

DO NOT create a new button design. ONLY desaturate and fade the existing button's colors.`
          };

          // Get the actual button image URL to use as source
          const sourceImageUrl = (assetConfig.uiElements as any)[button];
          const sourceImageId = (assetConfig.uiButtonImageIds as any)?.[button];

          if (!sourceImageUrl) {
            console.error(`âŒ No source image URL found for ${button}`);
            continue;
          }
          const result = await enhancedOpenaiClient.generateImageWithConfig({
            sourceImage: sourceImageUrl, // Use the actual button image URL
            sourceSymbolId: sourceImageId, // Also pass the stored ID for reference
            targetSymbolId: `ui_${button}_${state}`,
            gameId: config.gameId,
            count: 1,
            prompt: (statePrompts as any)[state]
          });

          if (result && result.success && result.images && result.images.length > 0) {
            if (state === 'pressed') {
              (newPressedButtons as any)[button] = result.images[0];
            } else if (state === 'disabled') {
              (newDisabledButtons as any)[button] = result.images[0];
            }
            generatedCount++;
          } else {
            console.error(`âŒ Failed to generate ${state} state for ${button}`);
          }
        } catch (error) {
          console.error(`Error generating ${state} state for ${button}:`, error);
        }
      }

      // Update the asset config with new button states
      updateAssetConfig('uiElementsPressed', newPressedButtons);
      updateAssetConfig('uiElementsDisabled', newDisabledButtons);

      // Also update the global config
      updateConfig({
        uiElementsPressed: newPressedButtons,
        uiElementsDisabled: newDisabledButtons,
        uiButtonImageIds: assetConfig.uiButtonImageIds
      } as any);

      showSuccess('Success', `Generated ${generatedCount} missing button states!`);

    } catch (error) {
      console.error('Error generating button states:', error);
      showWarning('Error', 'Failed to generate button states. Please try again.');
    } finally {
      updateAssetConfig('isGeneratingButtonStates', false);
    }
  };

  // Render the preset tab
  const renderPresetTab = () => {
    return (
      <div className="space-y-12">
        {/* Background section */}
        <div className="bg-white rounded-lg shadow-sm border border-gray-200">
          <div className="px-4 py-3 uw:px-8 border-b border-gray-200 border-l-4 border-l-red-500 bg-gray-50 ">
            <h3 className="text-lg uw:text-3xl font-semibold text-gray-900 flex items-center">
              {/* <Image className="w-5 h-5 mr-2 text-blue-600" /> */}
              Background (Desktop & Mobile)
            </h3>
          </div>

          <div className="p-4">
            <div className="flex w-full flex-col gap-1">
              <div className="w-full">
                <textarea
                  className="w-full h-24 p-3 border border-gray-300 rounded-md resize-none uw:text-xl"
                  placeholder="Describe the background you want for your slot game..."
                  value={assetConfig.backgroundPrompt}
                  onChange={(e) => updateAssetConfig('backgroundPrompt', e.target.value)}
                />
                <p className="text-xs uw:text-xl text-gray-500 mb-1">
                  AI will generate backgrounds optimized for both desktop (16:9) and mobile portrait (9:16)
                </p>
              </div>

              <div className="flex flex-co w-full gap-2">
                <Button
                  variant="generate"
                  onClick={generateBackground}
                  className='py-2 w-[50%]'
                  disabled={assetConfig.isGeneratingBackground}
                >
                  {assetConfig.isGeneratingBackground ? (
                    <>
                      <Loader className="w-5 h-5 animate-spin" />
                      Generating...
                    </>
                  ) : (
                    <>
                      <Sparkles className="w-5 h-5" />
                      Generate
                    </>
                  )}
                </Button>
                <Button
                  variant="uploadImage"
                  className='py-2 w-[50%]'
                  onClick={() => backgroundFileInputRef.current?.click()}
                >
                  <Upload className="w-5 h-5" />
                  Upload Image
                </Button>
                <input
                  type="file"
                  ref={backgroundFileInputRef}
                  className="hidden"
                  accept="image/png,image/jpeg,image/jpg,image/gif,image/webp"
                  onChange={handleBackgroundUpload}
                  key="background-upload"
                />
              </div>
            </div>


            {/* Preview current background */}
            {assetConfig.backgroundPath && (
              <div className="mt-4 p-3 bg-gray-50 rounded-md">
                <h4 className="text-sm uw:text-2xl font-medium text-gray-700 mb-2">Current Background</h4>
                <div 
                  className="relative aspect-video bg-gray-200 rounded-md overflow-hidden cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all duration-200 group"
                  onClick={() => setBackgroundInPreview(assetConfig.backgroundPath!, 'main')}
                  title="Click to set as background in preview"
                >
                  <img
                    src={assetConfig.backgroundPath}
                    alt="Background"
                    className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-200"
                  />
                  <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-all duration-200 flex items-center justify-center">
                    <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-blue-600 text-white px-3 py-1 rounded-full text-xs font-medium">
                      Set as Background
                    </div>
                  </div>
                </div>
              </div>
            )}
            {/* Background Control Panel */}
            {assetConfig.backgroundPath && (
              <div className="mt-4 p-4 bg-gradient-to-r from-indigo-50 to-purple-50 rounded-md border border-indigo-200">
                <h4 className="text-sm uw:text-2xl font-semibold text-indigo-800 mb-4 flex items-center">
                  <Settings className="w-4 h-4 mr-2" />
                  Background Controls
                </h4>

                {/* Device Preview Tabs */}
                <div className="flex gap-2 mb-4">
                  <button
                    className={`px-3 py-2 text-xs uw:text-xl rounded-md border transition-colors ${backgroundPreviewDevice === 'desktop'
                      ? 'border-indigo-500 bg-indigo-100 text-indigo-700'
                      : 'border-gray-300 hover:bg-gray-50'
                      }`}
                    onClick={() => {
                      setBackgroundPreviewDevice('desktop');
                      // Dispatch device mode change event for PixiJS preview
                      window.dispatchEvent(new CustomEvent('deviceModeChanged', {
                        detail: { mode: 'desktop' }
                      }));
                    }}
                  >
                    ðŸ–¥ï¸ Desktop
                  </button>
                  <button
                    className={`px-3 py-2 text-xs uw:text-xl rounded-md border transition-colors ${backgroundPreviewDevice === 'mobile-portrait'
                      ? 'border-indigo-500 bg-indigo-100 text-indigo-700'
                      : 'border-gray-300 hover:bg-gray-50'
                      }`}
                    onClick={() => {
                      setBackgroundPreviewDevice('mobile-portrait');
                      // Dispatch device mode change event for PixiJS preview
                      window.dispatchEvent(new CustomEvent('deviceModeChanged', {
                        detail: { mode: 'mobile', orientation: 'portrait' }
                      }));
                    }}
                  >
                    ðŸ“± Mobile Portrait
                  </button>
                  <button
                    className={`px-3 py-2 text-xs uw:text-xl rounded-md border transition-colors ${backgroundPreviewDevice === 'mobile-landscape'
                      ? 'border-indigo-500 bg-indigo-100 text-indigo-700'
                      : 'border-gray-300 hover:bg-gray-50'
                      }`}
                    onClick={() => {
                      setBackgroundPreviewDevice('mobile-landscape');
                      // Dispatch device mode change event for PixiJS preview
                      window.dispatchEvent(new CustomEvent('deviceModeChanged', {
                        detail: { mode: 'mobile', orientation: 'landscape' }
                      }));
                    }}
                  >
                    ðŸ“± Mobile Landscape
                  </button>
                </div>

                {/* Background Positioning Controls */}
                <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
                  <div>
                    <div className="flex justify-between mb-1">
                      <label className="text-xs uw:text-xl text-indigo-700 flex items-center">
                        <Move className="w-3 h-3 uw:w-5 uw:h-5 mr-1" />
                        X Position
                      </label>
                      <span className="text-xs uw:text-xl text-indigo-600">{assetConfig.backgroundPosition?.x || 0}%</span>
                    </div>
                    <input
                      type="range"
                      min="-100"
                      max="100"
                      value={assetConfig.backgroundPosition?.x || 0}
                      onChange={(e) => updateAssetConfig('backgroundPosition', {
                        ...assetConfig.backgroundPosition,
                        x: parseInt(e.target.value)
                      })}
                      className="w-full accent-indigo-500"
                    />
                  </div>

                  <div>
                    <div className="flex justify-between mb-1">
                      <label className="text-xs uw:text-xl text-indigo-700 flex items-center">
                        <Move className="w-3 h-3 uw:w-5 uw:h-5 mr-1" />
                        Y Position
                      </label>
                      <span className="text-xs uw:text-xl text-indigo-600">{assetConfig.backgroundPosition?.y || 0}%</span>
                    </div>
                    <input
                      type="range"
                      min="-100"
                      max="100"
                      value={assetConfig.backgroundPosition?.y || 0}
                      onChange={(e) => updateAssetConfig('backgroundPosition', {
                        ...assetConfig.backgroundPosition,
                        y: parseInt(e.target.value)
                      })}
                      className="w-full accent-indigo-500"
                    />
                  </div>

                  <div>
                    <div className="flex justify-between mb-1">
                      <label className="text-xs uw:text-xl text-indigo-700 flex items-center">
                        <ZoomIn className="w-3 h-3 uw:w-6 uw:h-6 mr-1" />
                        Scale
                      </label>
                      <span className="text-xs uw:text-xl text-indigo-600">{assetConfig.backgroundScale || 100}%</span>
                    </div>
                    <input
                      type="range"
                      min="50"
                      max="200"
                      value={assetConfig.backgroundScale || 100}
                      onChange={(e) => updateAssetConfig('backgroundScale', parseInt(e.target.value))}
                      className="w-full accent-indigo-500"
                    />
                  </div>
                </div>

                {/* Background Fit Options */}
                <div className="mt-4">
                  <label className="text-xs uw:text-2xl text-indigo-700 mb-2 block">Background Fit</label>
                  <div className="grid grid-cols-4 gap-2">
                    {['cover', 'contain', 'fill', 'scale-down'].map((fitMode) => (
                      <button
                        key={fitMode}
                        className={`p-2 text-xs uw:text-xl rounded-md border transition-colors ${assetConfig.backgroundFit === fitMode
                          ? 'border-indigo-500 bg-indigo-100 text-indigo-700'
                          : 'border-gray-300 hover:bg-gray-50'
                          }`}
                        onClick={() => updateAssetConfig('backgroundFit', fitMode)}
                      >
                        {fitMode.charAt(0).toUpperCase() + fitMode.slice(1).replace('-', ' ')}
                      </button>
                    ))}
                  </div>
                </div>

                {/* Device-Specific Background Generation */}
                <div className="mt-4 pt-4 border-t border-indigo-200">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-xs uw:text-2xl font-medium text-indigo-800">Device-Optimized Versions</span>
                    <button
                      className="text-xs uw:text-xl bg-indigo-600 text-white px-2 py-1 rounded hover:bg-indigo-700"
                      onClick={() => generateDeviceSpecificBackgrounds()}
                    >
                      Generate All
                    </button>
                  </div>
                  <div className="text-xs uw:text-xl text-indigo-600">
                    Auto-generate optimized backgrounds for different screen sizes and orientations
                  </div>
                </div>
              </div>
            )}

            {/* Background Variations - Derive Function */}
            {assetConfig.backgroundPath && (
              <div className="mt-4 p-4 bg-blue-50 rounded-md border border-blue-200">
                <div className="flex items-center justify-between mb-3">
                  <h4 className="text-sm uw:text-2xl font-medium text-blue-800 flex items-center">
                    <Copy className="w-4 h-4 mr-1" />
                    Background Variations (Game Modes)
                  </h4>
                </div>

                {/* Custom derive prompt */}
                <div className="mb-3">
                  <label className="block text-xs uw:text-xl font-medium text-blue-700 mb-1">
                    Custom Variation Description (Optional)
                  </label>
                  <textarea
                    className="w-full h-16 p-2 border border-blue-300 rounded text-xs resize-none uw:text-xl"
                    placeholder="Describe how you want to transform the background (e.g., 'Add golden magical effects and floating particles')"
                    value={assetConfig.derivePrompt}
                    onChange={(e) => updateAssetConfig('derivePrompt', e.target.value)}
                  />
                  <p className="text-xs uw:text-xl text-blue-600 mt-1">
                    Leave empty to use automatic transformation for each variation type
                  </p>
                </div>

                {/* Combined buttons with left-right content */}
                <div className="grid grid-cols-2 gap-2 mb-3">
                  <div className="relative rounded text-xs font-medium transition-colors">
                    <div className="flex items-center justify-around h-full">
                      {/* Left side - Generate */}
                      <button
                        className="flex items-center bg-indigo-600 hover:bg-indigo-700 h-full px-2 gap-1 text-white disabled:opacity-50 border-r w-full"
                        onClick={() => deriveBackground('night')}
                        disabled={assetConfig.isDeriving}
                      >
                        {assetConfig.isDeriving && assetConfig.derivingType === 'night' ? (
                          <Loader className="w-4 h-4 uw:w-5 uw:h-5 animate-spin" />
                        ) : (
                          <Moon className="w-4 h-4 uw:w-5 uw:h-5" />
                        )}
                        <span className="uw:text-xl">Generate Night version</span>
                      </button>
                      
                      {/* Right side - Upload */}
                      <label className="flex items-center gap-1 bg-indigo-600 hover:bg-indigo-700 px-2 h-full text-white cursor-pointer">
                        <Upload className="w-4 h-4 uw:w-5 uw:h-5" />
                        <span className="uw:text-xl">Upload</span>
                        <input
                          type="file"
                          accept="image/*"
                          className="hidden"
                          onChange={(e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                              const url = URL.createObjectURL(file);
                              updateAssetConfig('derivedBackgrounds', {
                                ...assetConfig.derivedBackgrounds,
                                night: url
                              });
                            }
                          }}
                        />
                      </label>
                    </div>
                  </div>

                  <div className="relative bg-yellow-600  rounded text-xs font-medium transition-colors">
                    <div className="flex items-center justify-around h-full">
                      {/* Left side - Generate */}
                      <button
                        className="flex items-center gap-1 px-2 text-white bg-yellow-600 hover:bg-yellow-700 disabled:opacity-50 border-r w-full h-full"
                        onClick={() => deriveBackground('day')}
                        disabled={assetConfig.isDeriving}
                      >
                        {assetConfig.isDeriving && assetConfig.derivingType === 'day' ? (
                          <Loader className="w-4 h-4 uw:w-5 uw:h-5 animate-spin" />
                        ) : (
                          <Sun className="w-4 h-4 uw:w-6 uw:h-6" />
                        )}
                        <span className="uw:text-xl">Generate Day version</span>
                      </button>
                      
                      {/* Right side - Upload */}
                      <label className="flex items-center gap-1 text-white cursor-pointer p-2 bg-yellow-600 hover:bg-yellow-700">
                        <Upload className="w-4 h-4 uw:w-5 uw:h-5" />
                        <span className="uw:text-xl">Upload</span>
                        <input
                          type="file"
                          accept="image/*"
                          className="hidden"
                          onChange={(e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                              const url = URL.createObjectURL(file);
                              updateAssetConfig('derivedBackgrounds', {
                                ...assetConfig.derivedBackgrounds,
                                day: url
                              });
                            }
                          }}
                        />
                      </label>
                    </div>
                  </div>
                </div>

                {/* Preview derived backgrounds */}
                {Object.keys(assetConfig.derivedBackgrounds).length > 0 && (
                  <div>
                    <h5 className="text-xs uw:text-2xl font-medium text-blue-700 mb-2">Generated Variations</h5>
                    <div className="grid grid-cols-2 gap-2">
                      {Object.entries(assetConfig.derivedBackgrounds).map(([type, url]) => (
                        <div key={type} className="relative">
                          <div
                            className="aspect-video bg-gray-200 rounded overflow-hidden cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all duration-200 group"
                            onClick={() => setBackgroundInPreview(url, type)}
                            title={`Click to set ${type} background in PixiJS preview`}
                          >
                            <img
                              src={url}
                              alt={`${type} background`}
                              className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-200"
                            />
                            <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-all duration-200 flex items-center justify-center">
                              <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-blue-600 text-white px-3 py-1 rounded-full text-xs font-medium">
                                Set as Background
                              </div>
                            </div>
                          </div>
                          <div className="absolute top-1 left-1 bg-black bg-opacity-75 text-white text-xs px-2 py-1 rounded">
                            {type.charAt(0).toUpperCase() + type.slice(1)}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                <div className="mt-3 text-xs uw:text-xl text-blue-600">
                  <p><strong>Usage:</strong> Each variation can be used for different game modes:</p>
                  <p>â€¢ <strong>Night/Day:</strong> Time-based themes or dual game modes</p>
                  <p className="mt-2 font-medium">ðŸ’¡ <strong>Tip:</strong> Click any generated background to set it in the PixiJS preview!</p>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Frame section */}
        <div className="bg-white rounded-lg shadow-sm border border-gray-200">
          <div className="px-4 py-3 uw:px-8  border-b border-gray-200 border-l-4 border-l-red-500 bg-gray-50">
            <h3 className="text-lg uw:text-3xl font-semibold text-gray-900 flex items-center">
              {/* <Frame className="w-5 h-5 mr-2 text-amber-600" /> */}
              Frame (Transparent PNG)
            </h3>
          </div>

          <div className="p-6">
            {/* Grid-Aware Frame Templates */}
            <div className="mb-6 px-4 py-3 uw:px-8 bg-gray-50 rounded-lg border border-gray-200">
              <h4 className="text-sm uw:text-2xl font-semibold text-gray-800 mb-5 flex items-center">
                {/* <Frame className="w-4 h-4 mr-2" /> */}
                Grid-Optimized Templates
                <span className="ml-2 text-xs uw:text-xl bg-gray-100 text-gray-700 px-2 py-1 rounded-full">
                  {config.reels?.layout?.reels}Ã—{config.reels?.layout?.rows}
                </span>
              </h4>

              <div className="grid grid-cols-2 lg:grid-cols-4 gap-2">
                <button
                  className={`${gridOptimize === "minimal" && 'bg-red-50 border-red-500'} p-3 uw:px-8 text-xs uw:text-2xl rounded-md border border-blue-200 transition-colors flex flex-col items-center`}
                  onClick={() => applyFrameTemplate('minimal')}
                >
                  <div className={`${gridOptimize === "minimal" && 'bg-red-200 border-red-400'} w-8 h-8 mb-1 bg-blue-200 rounded border-2 border-blue-400 relative`}>
                    {/* <div className="absolute inset-1 bg-transparent border border-red-300 rounded"></div> */}
                    <div className={`${gridOptimize === "minimal" && ' border-red-400'} absolute inset-1 bg-transparent border border-blue-300 rounded`}></div>
                  </div>
                  Minimal
                </button>

                <button
                  className={`${gridOptimize === "ornate" && 'bg-red-50 border-red-500'} p-3 uw:px-8 text-xs uw:text-2xl rounded-md border  border-blue-200  transition-colors flex flex-col items-center`}
                  onClick={() => applyFrameTemplate('ornate')}
                >
                  <div className={`${gridOptimize === "ornate" && 'bg-red-200 border-red-400'} w-8 h-8 mb-1 bg-blue-200 rounded border-4 border-blue-400 relative`}>
                    <div className={`${gridOptimize === "ornate" && ' border-red-400'} absolute inset-2 bg-transparent border border-blue-400 rounded`}></div>
                    <div className={`${gridOptimize === "ornate" && ' bg-red-500'} absolute -top-1 -left-1 w-2 h-2 bg-blue-500 rounded-full`}></div>
                    <div className={`${gridOptimize === "ornate" && ' bg-red-500'} absolute -top-1 -right-1 w-2 h-2 bg-blue-500 rounded-full`}></div>
                  </div>
                  Ornate
                </button>

                <button
                  className={`${gridOptimize === "reels" && 'bg-red-50 border-red-500'} p-3 uw:px-8 text-xs uw:text-2xl rounded-md border border-blue-200 transition-colors flex flex-col items-center`}
                  onClick={() => applyFrameTemplate('reels')}
                >
                  <div className={`${gridOptimize === "reels" && 'bg-red-200 border-red-400'} w-8 h-8 mb-1 bg-blue-200 rounded border-2 border-blue-400 relative flex`}>
                    <div className={`${gridOptimize === "reels" && ' border-red-400'} flex-1 border-r border-blue-300`}></div>
                    <div className={`${gridOptimize === "reels" && ' border-red-400'}  flex-1 border-r border-blue-300`}></div>
                    <div className="flex-1"></div>
                  </div>
                  Reel Dividers
                </button>

                <button
                  className={`${gridOptimize === "adaptive" && 'bg-red-50 border-red-500'} p-3 uw:px-8 text-xs uw:text-2xl rounded-md border border-blue-200 transition-colors flex flex-col items-center`}
                  onClick={() => applyFrameTemplate('adaptive')}
                >
                  <div className={`${gridOptimize === "adaptive" && 'bg-red-200 border-red-400'} w-8 h-8 mb-1 bg-blue-200 rounded border-2 border-blue-400 relative`}>
                    <div className={`${gridOptimize === "adaptive" && ' border-red-400'} absolute inset-1 bg-transparent border border-blue-400 rounded`}></div>
                  </div>
                  Auto-Fit
                </button>
              </div>

              <div className="mt-3 text-xs uw:text-xl text-gray-600 bg-white p-2 rounded">
                <strong>Smart Templates:</strong> Optimized for your {config.reels?.layout?.reels || 5}Ã—{config.reels?.layout?.rows || 3} grid layout
              </div>
            </div>

            {/* Frame style selector */}
            <div className="mb-4 border p-4 rounded-md bg-gray-50">
              <label className="text-sm uw:text-3xl font-medium text-gray-800 mb-5 block">Frame Style</label>
              <div className="grid grid-cols-3 gap-2">
                <button
                  className={`p-3 flex justify-center items-center uw:text-2xl rounded-lg border transition-all duration-200 ease-in-out ${assetConfig.frameStyle === 'outer'
                    ? ' border-blue-500 bg-gray-50 shadow-md font-semibold text-gray-900'
                    : 'border-gray-200 hover:border-gray-300 bg-white hover:bg-gray-50 hover:shadow-sm text-gray-700'
                    }`}
                  onClick={() => updateAssetConfig('frameStyle', 'outer')}
                >
                  Outer Frame
                </button>
                <button
                  className={`p-3 flex justify-center items-center uw:text-2xl rounded-lg border transition-all duration-200 ease-in-out ${assetConfig.frameStyle === 'reel'
                    ? ' border-blue-500 bg-gray-50 shadow-md font-semibold text-gray-900'
                    : 'border-gray-200 hover:border-gray-300 bg-white hover:bg-gray-50 hover:shadow-sm text-gray-700'
                    }`}
                  onClick={() => updateAssetConfig('frameStyle', 'reel')}
                >
                  Reel Frame
                </button>
                <button
                  className={`p-2 flex justify-center items-center uw:text-2xl rounded-lg border transition-all duration-200 ease-in-out ${assetConfig.frameStyle === 'both'
                    ? ' border-blue-500 bg-gray-50 shadow-md font-semibold text-gray-900'
                    : 'border-gray-200 hover:border-gray-300 bg-white hover:bg-gray-50 hover:shadow-sm text-gray-700'
                    }`}
                  onClick={() => updateAssetConfig('frameStyle', 'both')}
                >
                  Both
                </button>
              </div>
            </div>
            {assetConfig.frameStyle !== 'reel' &&
              <div className="flex flex-col gap-4">
                <div className="col-span-2">
                  <textarea
                    className="w-full h-24 p-3 uw:text-xl border border-gray-300 rounded-md resize-none"
                    placeholder="Enter frame style (e.g., aztec temple, forest roots, candy canes, golden ornate)"
                    value={assetConfig.framePrompt}
                    onChange={(e) => {
                      updateAssetConfig('framePrompt', e.target.value);
                    }}
                  />
                  <p className="text-xs uw:text-xl text-gray-500 mt-1">
                    Frame will be transparent PNG that surrounds the symbols grid
                  </p>
                </div>

                <div className="flex gap-2">
                  <Button
                    variant='generate'
                    className='py-2 w-[50%]'
                    onClick={generateFrame}
                    disabled={assetConfig.isGeneratingFrame}
                  >
                    {assetConfig.isGeneratingFrame ? (
                      <>
                        <Loader className="w-5 h-5 animate-spin" />
                        Generating...
                      </>
                    ) : (
                      <>
                        <Sparkles className="w-5 h-5" />
                        Generate
                      </>
                    )}
                  </Button>

                  <Button
                    variant='uploadImage'
                    className='py-2 w-[50%]'
                    onClick={() => frameFileInputRef.current?.click()}
                  >
                    <Upload className="w-5 h-5" />
                    Upload Image
                  </Button>
                  <input
                    type="file"
                    ref={frameFileInputRef}
                    className="hidden"
                    accept="image/png,image/jpeg,image/jpg,image/gif,image/webp"
                    onChange={handleFrameUpload}
                    key="frame-upload"
                  />
                </div>
              </div>
            }
            {/* Frame validation indicator */}
            {assetConfig.framePath && (
              <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <CheckCircle className="w-4 h-4 text-green-500" />
                    <span className="text-sm uw:text-2xl text-blue-800">Frame Validation</span>
                  </div>
                  <button
                    className="text-xs uw:text-xl bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700"
                    onClick={() => validateFrame(assetConfig.framePath!)}
                  >
                    Check Quality
                  </button>
                </div>
                <div className="mt-2 text-xs uw:text-xl text-blue-600">
                  â€¢ Grid compatibility: {config.reels?.layout?.reels || 5}Ã—{config.reels?.layout?.rows || 3} âœ“
                  â€¢ Transparency check: Automated validation available
                  â€¢ Professional quality: AI-optimized for slot games
                </div>
              </div>
            )}
            {/* AI Reel Generation */}
            <div className="mt-6 p-4 bg-purple-50 rounded-md border border-purple-200">
              <h5 className="text-sm uw:text-3xl font-medium text-purple-800 mb-3">
                <Layers className="w-4 h-4 inline mr-1" />
                AI Reel Images (Instead of Lines)
              </h5>
              <p className="text-xs uw:text-2xl text-purple-700 mb-3">
                Generate AI reel separator images to replace simple lines with decorative reel elements
              </p>

              <div className="space-y-3">
                <div>
                  <textarea
                    className="w-full h-16 p-2 border border-purple-300 rounded-md resize-none text-sm uw:text-xl"
                    placeholder="Describe the reel separator style (e.g., 'golden ornate vertical dividers with decorative patterns')..."
                    value={assetConfig.aiReelPrompt}
                    onChange={(e) => updateAssetConfig('aiReelPrompt', e.target.value)}
                  />
                </div>

                <button
                  className="flex items-center justify-center gap-2 bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-md font-medium transition-colors disabled:opacity-50 w-full uw:text-2xl"
                  onClick={generateAIReel}
                  disabled={assetConfig.isGeneratingAIReel}
                >
                  {assetConfig.isGeneratingAIReel ? (
                    <Loader className="w-4 h-4 animate-spin" />
                  ) : (
                    <Layers className="w-6 h-6" />
                  )}
                  {assetConfig.isGeneratingAIReel ? 'Generating AI Reel...' : 'Generate AI Reel Image'}
                </button>

                {/* Display generated AI reel */}
                {assetConfig.aiReelImage && (
                  <div className="mt-3 p-2 bg-white rounded border">
                    <div className="flex items-center justify-between mb-3 mx-4">
                      <span className="text-xs uw:text-2xl font-medium text-gray-700">Generated AI Reel:</span>
                      <span className="text-xs uw:text-2xl  text-green-600">âœ“ Active</span>
                    </div>
                    <div className="aspect-[1/4] bg-gray-200 rounded overflow-hidden max-w-16 mx-auto">
                      <img
                        src={assetConfig.aiReelImage}
                        alt="AI Reel Separator"
                        className="w-full h-full object-cover"
                      />
                    </div>
                    <p className="text-xs uw:text-3xl text-gray-600 mt-2 text-center">
                      This image will replace line dividers in the preview
                    </p>
                  </div>
                )}
              </div>
            </div>
            {/* Frame adjustment controls */}
            <div className="mt-4 p-4 bg-gray-50 border rounded-md">
              <div className="flex justify-between items-center mb-4">
                <h4 className="text-lg uw:text-4xl font-medium text-gray-800">
                  {assetConfig.frameStyle === 'reel' ? 'Reel Divider Adjustments' : 'Frame Adjustments'}
                </h4>
                {assetConfig.frameStyle !== 'reel' && (
                  <button
                    className="flex items-center gap-1 text-[0.8rem] bg-blue-600 text-white px-2 py-3 rounded hover:bg-blue-700 uw:text-3xl"
                    onClick={autoAdjustFrame}
                  >
                    <CheckCircle className="w-5 h-5" />
                    Auto-Adjust
                  </button>
                )}
              </div>

              {/* Conditional controls based on frame style */}
              {assetConfig.frameStyle === 'reel' ? (
                // Reel Divider Controls
                <div className="space-y-4">


                  <div className="space-y-4">
                    {/* Gap Between Reels Control */}
                    <div>
                      <div className="flex justify-between mb-1">
                        <label className="text-xs uw:text-3xl text-gray-600">Gap Between Reels</label>
                        <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.reelGap}px</span>
                      </div>
                      <input
                        type="range"
                        min="1"
                        max="200"
                        value={assetConfig.reelGap}
                        onChange={(e) => updateAssetConfig('reelGap', parseInt(e.target.value))}
                        className="w-full"
                      />
                    </div>

                    {/* Position Controls */}
                    <div className="grid grid-cols-2 gap-4">
                      {/* Horizontal Position */}
                      <div>
                        <div className="flex justify-between mb-1">
                          <label className="text-xs uw:text-3xl text-gray-600 flex items-center">
                            <ArrowLeftRight className="w-6 h-6 mr-1" />
                            Horizontal Position
                          </label>
                          <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.reelDividerPosition.x}px</span>
                        </div>
                        <input
                          type="range"
                          min="-50"
                          max="50"
                          value={assetConfig.reelDividerPosition.x}
                          onChange={(e) => updateAssetConfig('reelDividerPosition', { ...assetConfig.reelDividerPosition, x: parseInt(e.target.value) })}
                          className="w-full"
                        />
                      </div>

                      {/* Vertical Position */}
                      <div>
                        <div className="flex justify-between mb-1">
                          <label className="text-xs uw:text-3xl text-gray-600 flex items-center">
                            <ArrowUpDown className="w-6 h-6 mr-1" />
                            Vertical Position
                          </label>
                          <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.reelDividerPosition.y}px</span>
                        </div>
                        <input
                          type="range"
                          min="-50"
                          max="50"
                          value={assetConfig.reelDividerPosition.y}
                          onChange={(e) => updateAssetConfig('reelDividerPosition', { ...assetConfig.reelDividerPosition, y: parseInt(e.target.value) })}
                          className="w-full"
                        />
                      </div>
                    </div>

                    {/* Stretch Controls */}
                    <div className="grid grid-cols-2 gap-4">
                      {/* Horizontal Stretch */}
                      <div>
                        <div className="flex justify-between mb-1">
                          <label className="text-xs uw:text-3xl text-gray-600">Horizontal Stretch</label>
                          <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.reelDividerStretch.x}%</span>
                        </div>
                        <input
                          type="range"
                          min="50"
                          max="300"
                          value={assetConfig.reelDividerStretch.x}
                          onChange={(e) => updateAssetConfig('reelDividerStretch', { ...assetConfig.reelDividerStretch, x: parseInt(e.target.value) })}
                          className="w-full"
                        />
                      </div>

                      {/* Vertical Stretch */}
                      <div>
                        <div className="flex justify-between mb-1">
                          <label className="text-xs uw:text-3xl text-gray-600">Vertical Stretch</label>
                          <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.reelDividerStretch.y}%</span>
                        </div>
                        <input
                          type="range"
                          min="50"
                          max="200"
                          value={assetConfig.reelDividerStretch.y}
                          onChange={(e) => updateAssetConfig('reelDividerStretch', { ...assetConfig.reelDividerStretch, y: parseInt(e.target.value) })}
                          className="w-full"
                        />
                      </div>
                    </div>


                  </div>
                </div>
              ) : (
                // Standard Frame Controls (for 'outer' and 'both' styles)
                <div>
                  <div className='mb-4'>
                    <div className="flex justify-between mb-1">
                      <label className="text-xs uw:text-3xl text-gray-600 flex items-center">
                        <ZoomIn className="w-6 h-6 mr-1" />
                        Scale
                      </label>
                      <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.frameScale}%</span>
                    </div>
                    <input
                      type="range"
                      min="80"
                      max="120"
                      value={assetConfig.frameScale}
                      onChange={(e) => updateAssetConfig('frameScale', parseInt(e.target.value))}
                      className="w-full"
                    />
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    {/* X Position adjustment */}
                    <div>
                      <div className="flex justify-between mb-1">
                        <label className="text-xs uw:text-3xl text-gray-600 flex items-center">
                          <ArrowLeftRight className="w-6 h-6 mr-1" />
                          Horizontal Position
                        </label>
                        <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.framePosition.x}px</span>
                      </div>
                      <input
                        type="range"
                        min="-50"
                        max="50"
                        value={assetConfig.framePosition.x}
                        onChange={(e) => updateAssetConfig('framePosition', { ...assetConfig.framePosition, x: parseInt(e.target.value) })}
                        className="w-full"
                      />
                    </div>

                    {/* Y Position adjustment */}
                    <div>
                      <div className="flex justify-between mb-1">
                        <label className="text-xs uw:text-3xl text-gray-600 flex items-center">
                          <ArrowUpDown className="w-6 h-6 mr-1" />
                          Vertical Position
                        </label>
                        <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.framePosition.y}px</span>
                      </div>
                      <input
                        type="range"
                        min="-50"
                        max="50"
                        value={assetConfig.framePosition.y}
                        onChange={(e) => updateAssetConfig('framePosition', { ...assetConfig.framePosition, y: parseInt(e.target.value) })}
                        className="w-full"
                      />
                    </div>

                    {/* X Stretch adjustment */}
                    <div>
                      <div className="flex justify-between mb-1">
                        <label className="text-xs uw:text-3xl text-gray-600">Horizontal Stretch</label>
                        <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.frameStretch.x}%</span>
                      </div>
                      <input
                        type="range"
                        min="80"
                        max="120"
                        value={assetConfig.frameStretch.x}
                        onChange={(e) => updateAssetConfig('frameStretch', { ...assetConfig.frameStretch, x: parseInt(e.target.value) })}
                        className="w-full"
                      />
                    </div>

                    {/* Y Stretch adjustment */}
                    <div>
                      <div className="flex justify-between mb-1">
                        <label className="text-xs uw:text-3xl text-gray-600">Vertical Stretch</label>
                        <span className="text-xs uw:text-3xl text-gray-600">{assetConfig.frameStretch.y}%</span>
                      </div>
                      <input
                        type="range"
                        min="80"
                        max="120"
                        value={assetConfig.frameStretch.y}
                        onChange={(e) => updateAssetConfig('frameStretch', { ...assetConfig.frameStretch, y: parseInt(e.target.value) })}
                        className="w-full"
                      />
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Preview current frame */}
            {assetConfig.framePath && (
              <div className="mt-4 p-3 bg-gray-50 rounded-md">
                <h4 className="text-sm uw:text-3xl font-medium text-gray-700 mb-2">Current Frame</h4>
                <div className="bg-gray-200 rounded-md overflow-hidden h-32 flex items-center justify-center">
                  <img
                    src={assetConfig.framePath}
                    alt="Frame"
                    className="max-w-full max-h-full object-contain"
                  />
                </div>
              </div>
            )}
          </div>
        </div>

        {/* UI Elements section */}
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 mb-4">
          <div className="px-4 py-3 uw:px-8 border-b border-gray-200 border-l-4 border-l-red-500 bg-gray-50">
            <h3 className="text-lg uw:text-3xl font-semibold text-gray-800 flex items-center">
              UI Elements (Transparent Icons)
            </h3>
          </div>

          <div className="p-6">
            <div className="mb-4 w-full gap-2 flex items-center justify-center">
              <label className="text-sm uw:text-2xl w-[10%] font-medium text-gray-700  block">UI Layout:</label>
              <select
                className="w-[90%] p-2 border border-gray-300 rounded-md uw:text-2xl"
                value={uiType}
                onChange={(e) => setUiType(e.target.value as UiDesigns)}
              >
                <option value="normal">Normal</option>
                <option value="modern">Modern</option>
                <option value="simple">Simple</option>
                <option value="ultimate">Ultimate</option>
              </select>
            </div>

            <div className="flex flex-col gap-4">
              <div className="col-span-2">
                <textarea
                  className="w-full h-24 p-3 border border-gray-300 rounded-md resize-none uw:text-3xl"
                  placeholder="Describe the UI button style you want..."
                  value={assetConfig.uiButtonsPrompt}
                  onChange={(e) => updateAssetConfig('uiButtonsPrompt', e.target.value)}
                />
                <p className="text-xs uw:text-2xl text-gray-500 mt-1">
                  AI will generate individual casino-style buttons: SPIN, AUTO, MENU, SOUND, and SETTINGS
                </p>
                {assetConfig.isGeneratingUIButtons && (
                  <p className="text-xs uw:text-2xl text-blue-600 mt-1 font-medium">
                    â³ Generating individual buttons... This creates 5 separate high-quality casino buttons (2-5 minutes).
                  </p>
                )}
              </div>

              <div className="flex w-full gap-2">
                <Button
                  variant='generate'
                  className='py-2 w-[50%] uw:text-3xl'
                  onClick={() => generateIndividualUIButtons()}
                  disabled={assetConfig.isGeneratingUIButtons}
                >
                  {assetConfig.isGeneratingUIButtons ? (
                    <>
                      <Loader className="w-6 h-7 uw:w-8 uw:h-9 animate-spin mx-2" />
                      Generating All Buttons...
                    </>
                  ) : (
                    <>
                      <Sparkles className="w-6 h-7 uw:w-8 uw:h-9 mx-2" />
                      Generate All Buttons
                    </>
                  )}
                </Button>

                <Button
                  variant='uploadImage'
                  className='py-2 w-[50%] uw:text-3xl'
                  onClick={() => uiButtonsFileInputRef.current?.click()}
                >
                  <Upload className="w-6 h-7 uw:w-8 uw:h-9 mx-2" />
                  Upload Image
                </Button>
                <input
                  type="file"
                  ref={uiButtonsFileInputRef}
                  className="hidden"
                  accept="image/png,image/jpeg,image/jpg,image/gif,image/webp"
                  onChange={handleUIButtonsUpload}
                  key="ui-buttons-upload"
                />
              </div>

              {/* Alternative generation methods */}
              <div className="flex w-full gap-2 mt-2">
                <Button
                  variant='uploadImage'
                  className='py-2 w-[50%] text-xs uw:text-3xl'
                  onClick={() => generateUIButtons()}
                  disabled={assetConfig.isGeneratingUIButtons}
                >
                  <Grid3X3 className="w-6 h-7 uw:w-8 uw:h-9 mx-2" />
                  Generate Button Sheet (Fallback)
                </Button>

                <Button
                  variant='uploadImage'
                  className='py-2 w-[50%] text-xs uw:text-3xl'
                  onClick={() => {
                    updateAssetConfig('uiElements', {});
                    updateAssetConfig('extractedUIButtons', {});
                    updateAssetConfig('uiButtonsPath', null);
                  }}
                >
                  <RefreshCw className="w-6 h-7 uw:w-8 uw:h-8 mx-2" />
                  Clear All Buttons
                </Button>
              </div>
            </div>

            {/* Layout guide
            <div className="mt-4 p-3 bg-gray-50 rounded-md border border-gray-200">
              <h4 className="text-sm uw:text-4xl font-medium text-gray-800 mb-2 flex items-center">
                <Info className="w-6 h-7 uw:w-8  uw:h-9  mr-2" />
                Button Layout Guide
              </h4>
              <div className="flex items-center justify-center">
                <div className="flex bg-white border-2 border-gray-300 rounded-md overflow-hidden items-center gap-2 p-2 uw:text-3xl uw:p-4 uw:gap-4">
                  {[
                    { name: 'spinButton', label: 'SPIN', color: 'blue-700 uw:text-2xl' },
                    { name: 'autoplayButton', label: 'AUTO', color: 'green-700 uw:text-2xl' },
                    { name: 'menuButton', label: 'MENU', color: 'purple-700 uw:text-2xl' },
                    { name: 'soundButton', label: 'SOUND', color: 'orange-700 uw:text-2xl' },
                    { name: 'settingsButton', label: 'SETTINGS', color: 'gray-700 uw:text-2xl' },
                  ].map(({ name, label, color }) => (
                    <div
                      key={name}
                      className={`w-14 h-14 uw:w-28  uw:h-28 border-2 rounded-full flex flex-col items-center justify-center bg-gray-50 cursor-pointer m-1 ${selectedUIButton === name ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}`}
                      onClick={() => {
                        setSelectedUIButton(name as keyof typeof assetConfig.uiElements);
                        setSingleUIButtonPrompt('');
                      }}
                    >
                      <span className={`text-xs uw:text-xl font-bold text-${color}`}>{label}</span>
                    </div>
                  ))}
                </div>
              </div>
              <p className="text-xs uw:text-2xl text-gray-600 mt-2 text-center">
                Click a button above to select it, then generate or upload a replacement below
              </p>
            </div> */}

            

            {/* UI elements preview */}
              <div className="mt-4 space-y-4 p-3 bg-gray-50 rounded-md border border-gray-200">
                <div className='flex items-center justify-center gap-2'>

                <h4 className="text-sm uw:text-3xl font-medium text-gray-700">UI Elements Preview</h4>
                <p className="text-xs uw:text-xl text-gray-500">
                  (Click any button below to select it for individual generation or upload)
                </p>
                </div>

                {/* Interactive button preview */}
                <div className="p-4 bg-gray-50 rounded-md">
                  <div className="flex items-center justify-center gap-3">
                    {[
                      { name: 'spinButton', label: 'Spin', size: 'w-14 h-14 uw:w-28 uw:h-28', icon: Play },
                      { name: 'autoplayButton', label: 'Autoplay', size: 'w-14 h-14 uw:w-28 uw:h-28', icon: RefreshCw },
                      { name: 'menuButton', label: 'Menu', size: 'w-14 h-14 uw:w-28 uw:h-28', icon: Menu },
                      { name: 'soundButton', label: 'Sound', size: 'w-14 h-14 uw:w-28 uw:h-28', icon: Volume2 },
                      { name: 'settingsButton', label: 'Settings', size: 'w-14 h-14 uw:w-28 uw:h-28', icon: Settings }
                    ].map(({ name, label, size, icon: Icon }) => {
                      const normalImage = (assetConfig.uiElements as any)[name];
                      const isSelected = selectedUIButton === name;

                      return (
                        <div 
                          key={name} 
                          className="flex flex-col items-center cursor-pointer transition-all"
                          onClick={() => {
                            setSelectedUIButton(name as keyof typeof assetConfig.uiElements);
                            setSingleUIButtonPrompt('');
                          }}
                        >
                          <div
                            className={`${size} relative transition-all ${
                              isSelected 
                                ? 'ring-2 ring-blue-500 ring-offset-2 scale-105' 
                                : 'hover:ring-2 hover:ring-blue-300 hover:scale-105'
                            } rounded-full`}
                          >
                            {normalImage ? (
                              <img
                                src={normalImage}
                                alt={label}
                                className="w-full h-full object-contain rounded-full"
                                style={{
                                  filter: 'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3))'
                                }}
                              />
                            ) : (
                              <div className={`w-full h-full rounded-full flex items-center justify-center transition-colors ${
                                isSelected ? 'bg-blue-200' : 'bg-gray-200 hover:bg-gray-300'
                              }`}>
                                <Icon className={name === 'spinButton' ? 'w-10 h-10 uw:w-20 uw:h-20' : 'w-6 h-6 uw:w-9 uw:h-10'} />
                              </div>
                            )}
                            
                          </div>
                          <span className={`text-xs uw:text-xl mt-1 transition-colors ${
                            isSelected 
                              ? 'text-blue-600 font-bold' 
                              : name === 'spinButton' 
                                ? 'text-gray-700 font-semibold' 
                                : 'text-gray-600'
                          }`}>
                            {label}
                          </span>
                        </div>
                      );
                    })}
                  </div>

                  {/* UI Bar Preview */}
                  {assetConfig.uiBar && (
                    <div className="mt-4">
                      <h5 className="text-xs uw:text-2xl font-medium text-gray-600 mb-2">UI Bar</h5>
                      <div className="w-full h-16 rounded overflow-hidden">
                        <img
                          src={assetConfig.uiBar}
                          alt="UI Bar"
                          className="w-full h-full object-cover"
                        />
                      </div>
                    </div>
                  )}
                </div>
                {/* Individual Button Generation/Upload */}
            {selectedUIButton && (
              <div className="mt-4 p-4 bg-blue-50 rounded-md border border-blue-300">
                <h4 className="text-sm uw:text-3xl font-semibold text-blue-800 mb-3 flex items-center">
                  <Sparkles className="w-4 h-4 mr-2 uw:w-7 uw:h-8" />
                  Generate/Upload Individual Button: {selectedUIButton.replace('Button', '').toUpperCase()}
                </h4>

                <div className="space-y-3">
                  <textarea
                    className="w-full h-20 p-2 border border-blue-300 rounded-md resize-none text-sm uw:text-xl"
                    placeholder={`Describe the ${selectedUIButton.replace('Button', '')} button style...`}
                    value={singleUIButtonPrompt}
                    onChange={(e) => setSingleUIButtonPrompt(e.target.value)}
                  />

                  <div className="flex gap-2">
                    <Button
                      variant="generate"
                      className="py-2 w-[50%]"
                      onClick={async () => {
                        if (!selectedUIButton) return;

                        updateAssetConfig('isGeneratingUIButtons', true);
                        try {
                          const themeName = typeof config.theme === 'string'
                            ? config.theme
                            : (config.theme?.mainTheme || config.theme?.name || 'casino');

                          const buttonLabels = {
                            spinButton: 'SPIN',
                            autoplayButton: 'AUTO',
                            menuButton: 'MENU',
                            soundButton: 'SOUND',
                            settingsButton: 'SETTINGS'
                          };

                          const customPrompt = singleUIButtonPrompt.trim();
                          const basePrompt = customPrompt || `${themeName} themed ${selectedUIButton.replace('Button', '')} button`;

                          const enhancedPrompt = `Create a premium casino ${buttonLabels[selectedUIButton]} button for slot machine games.
                            DESIGN REQUIREMENTS:
                            - ${selectedUIButton === 'spinButton' ? 'Medium circular' : 'Rounded rectangle'} button centered on 1024x1024 canvas
                            - "${buttonLabels[selectedUIButton]}" text clearly visible
                            - 3D beveled edges with realistic lighting from top-left
                            - Glossy finish with light reflections and highlights
                            - Professional casino game aesthetic
                            - Transparent/black background outside the button
                            - Button should look highly pressable and interactive
                            - Size: approximately ${selectedUIButton === 'spinButton' ? '200-250' : '150-180'}px on the canvas
                            STYLE: ${basePrompt}
                            Create a beautiful button that matches the theme!`;

                          const result = await enhancedOpenaiClient.generateImageWithConfig({
                            prompt: enhancedPrompt,
                            targetSymbolId: `ui_${selectedUIButton}_normal`,
                            gameId: config.gameId,
                            count: 1
                          });

                          if (result?.success && result.images && result.images.length > 0) {
                            const newElements = { ...assetConfig.uiElements, [selectedUIButton]: result.images[0] };
                            const newExtracted = { ...assetConfig.extractedUIButtons, [selectedUIButton]: result.images[0] };
                            const newImageIds = { ...assetConfig.uiButtonImageIds, [selectedUIButton]: `ui_${selectedUIButton}_normal` };

                            updateAssetConfig('uiElements', newElements);
                            updateAssetConfig('extractedUIButtons', newExtracted);
                            updateAssetConfig('uiButtonImageIds', newImageIds);

                            updateConfig({ uiElements: newElements, extractedUIButtons: newExtracted, uiButtonImageIds: newImageIds } as any);

                            window.dispatchEvent(new CustomEvent('individualButtonsUpdated', { detail: { buttons: newElements } }));
                            showSuccess('Success', `${buttonLabels[selectedUIButton]} button generated successfully!`);
                          }
                        } catch (error) {
                          console.error('Error generating button:', error);
                          showWarning('Error', 'Failed to generate button. Please try again.');
                        } finally {
                          updateAssetConfig('isGeneratingUIButtons', false);
                        }
                      }}
                      disabled={assetConfig.isGeneratingUIButtons}
                    >
                      {assetConfig.isGeneratingUIButtons ? (
                        <><Loader className="w-5 h-5 animate-spin" />Generating...</>
                      ) : (
                        <><Sparkles className="w-5 h-5" />Generate</>
                      )}
                    </Button>

                    <Button
                      variant="uploadImage"
                      className="py-2 w-[50%]"
                      onClick={() => singleUIButtonFileInputRef.current?.click()}
                    >
                      <Upload className="w-5 h-5" />
                      Upload
                    </Button>
                    <input
                      type="file"
                      ref={singleUIButtonFileInputRef}
                      className="hidden"
                      accept="image/png,image/jpeg,image/jpg,image/gif,image/webp"
                      onChange={(e) => {
                        const files = e.target.files;
                        if (!files || files.length === 0 || !selectedUIButton) return;

                        const file = files[0];
                        if (!file.type.startsWith('image/')) {
                          alert('Please select an image file');
                          return;
                        }

                        const reader = new FileReader();
                        reader.onload = (event) => {
                          if (event.target && typeof event.target.result === 'string') {
                            const newElements = { ...assetConfig.uiElements, [selectedUIButton]: event.target.result };
                            const newExtracted = { ...assetConfig.extractedUIButtons, [selectedUIButton]: event.target.result };

                            updateAssetConfig('uiElements', newElements);
                            updateAssetConfig('extractedUIButtons', newExtracted);
                            updateConfig({ uiElements: newElements, extractedUIButtons: newExtracted } as any);

                            window.dispatchEvent(new CustomEvent('individualButtonsUpdated', { detail: { buttons: newElements } }));
                            showSuccess('Success', 'Button uploaded successfully!');
                          }
                        };
                        reader.readAsDataURL(file);
                      }}
                      key={`single-button-upload-${selectedUIButton}`}
                    />
                  </div>

                  <p className="text-xs uw:text-xl text-blue-700">
                    This will only replace the {selectedUIButton.replace('Button', '').toUpperCase()} button. All other buttons will remain unchanged.
                  </p>
                </div>
              </div>
            )}

                {/* Advanced Button State Management */}
                {assetConfig.uiElements.spinButton && (
                  <div className="mt-6 p-4 bg-gradient-to-r from-green-50 to-emerald-50 rounded-md border border-green-200">
                    <h4 className="text-sm uw:text-3xl font-semibold text-green-800 mb-4 flex items-center">
                      <Settings className="w-4 h-4 uw:w-6 uw:h-7 mr-2" />
                      Advanced Button Controls
                    </h4>

                    {/* Button State Manager */}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                      <div>
                        <h5 className="text-sm uw:text-2xl font-medium text-green-700 mb-3">Button States</h5>
                        <div className="space-y-3">
                          {['spinButton', 'autoplayButton', 'menuButton', 'soundButton', 'settingsButton'].map((buttonName) => (
                            <div key={buttonName} className="p-3 bg-white rounded border border-green-200">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xs uw:text-xl font-medium text-green-800 capitalize">
                                  {buttonName.replace('Button', '')}
                                </span>
                                <div className="flex gap-1">
                                  <span className={`w-2 h-2 rounded-full ${assetConfig.uiElements[buttonName] ? 'bg-green-500' : 'bg-gray-300'}`} title="Normal"></span>
                                  <span className={`w-2 h-2 rounded-full ${assetConfig.uiElementsPressed?.[buttonName] ? 'bg-blue-500' : 'bg-gray-300'}`} title="Pressed"></span>
                                  <span className={`w-2 h-2 rounded-full ${assetConfig.uiElementsDisabled?.[buttonName] ? 'bg-red-500' : 'bg-gray-300'}`} title="Disabled"></span>
                                </div>
                              </div>
                              <div className="grid grid-cols-3 gap-2 text-xs uw:text-xl">
                                <div className="text-center">
                                  <div className="w-8 h-8 mx-auto mb-1 border rounded overflow-hidden uw:h-20 uw:w-20">
                                    {assetConfig.uiElements[buttonName] ? (
                                      <img src={assetConfig.uiElements[buttonName]} alt="Normal" className="w-full h-full object-cover" />
                                    ) : (
                                      <div className="w-full h-full bg-gray-100"></div>
                                    )}
                                  </div>
                                  <span className="text-green-600">Normal</span>
                                </div>
                                <div className="text-center">
                                  <div className="w-8 h-8 mx-auto mb-1 border rounded overflow-hidden uw:h-20 uw:w-20">
                                    {assetConfig.uiElementsPressed?.[buttonName] ? (
                                      <img src={assetConfig.uiElementsPressed[buttonName]} alt="Pressed" className="w-full h-full object-cover" />
                                    ) : (
                                      <div className="w-full h-full bg-gray-100"></div>
                                    )}
                                  </div>
                                  <span className="text-blue-600">Pressed</span>
                                </div>
                                <div className="text-center">
                                  <div className="w-8 h-8 mx-auto mb-1 border rounded overflow-hidden uw:h-20 uw:w-20">
                                    {assetConfig.uiElementsDisabled?.[buttonName] ? (
                                      <img src={assetConfig.uiElementsDisabled[buttonName]} alt="Disabled" className="w-full h-full object-cover" />
                                    ) : (
                                      <div className="w-full h-full bg-gray-100"></div>
                                    )}
                                  </div>
                                  <span className="text-red-600">Disabled</span>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                      <div>
                        <h5 className="text-sm uw:text-3xl font-medium text-green-700 mb-3">Button Layout & Positioning</h5>
                        <div className="p- bg-white rounded border border-green-200">
                          <div className="space-y-">
                            <button
                              className={`w-full text-xs uw:text-xl py-2 px-3 rounded transition-colors flex items-center justify-center gap-2 ${assetConfig.isGeneratingButtonStates
                                ? 'bg-green-400 text-white cursor-not-allowed'
                                : 'bg-green-600 hover:bg-green-700 text-white'
                                }`}
                              onClick={() => regenerateButtonStates()}
                              disabled={assetConfig.isGeneratingButtonStates}
                            >
                              {assetConfig.isGeneratingButtonStates ? (
                                <>
                                  <Loader className="w-3 h-3 animate-spin" />
                                  Generating States...
                                </>
                              ) : (
                                'Generate Missing States'
                              )}
                            </button>
                          </div>
                        </div>
                        {/* UI Button Positioning & Visibility Controls */}
                        <div className="mt-4 p-2 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-md border border-blue-200">
                          <h5 className="text-sm uw:text-3xl font-medium text-blue-700 mb-3 flex items-center">
                            UI Button Adjustments
                          </h5>

                          <div className="flex flex-col gap-2">
                            {/* Position Controls - Only shown when a button is selected */}
                            {selectedUIButton ? (
                              <div className="space-y-1">
                                <div className="flex items-center justify-between pl-2">
                                  <h6 className="text-xs uw:text-xl font-medium text-gray-800">
                                    Position: {selectedUIButton.replace('Button', '').toUpperCase()}
                                  </h6>
                                  {((assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.x !== 0 || 
                                    (assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.y !== 0) && (
                                    <button
                                      onClick={() => {
                                        const newPositions = {
                                          ...(assetConfig.uiButtonPositions || {}),
                                          [selectedUIButton]: { x: 0, y: 0 }
                                        };
                                        updateAssetConfig('uiButtonPositions', newPositions);
                                      }}
                                      className="text-blue-600 hover:text-blue-800 hover:bg-blue-100 rounded p-1 transition-colors"
                                      title="Reset to 0,0"
                                    >
                                      <RotateCcw className="w-4 h-4 uw:w-5 uw:h-5" />
                                    </button>
                                  )}
                                </div>
                                <div className='p-2 border rounded-md bg-gray-50'>
                                  <label className="text-xs uw:text-xl text-blue-700 block">Horizontal Offset</label>
                                  <input
                                    type="range"
                                    min="-200"
                                    max="200"
                                    value={(assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.x || 0}
                                    onChange={(e) => {
                                      const newPositions = {
                                        ...(assetConfig.uiButtonPositions || {}),
                                        [selectedUIButton]: {
                                          x: parseInt(e.target.value),
                                          y: (assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.y || 0
                                        }
                                      };
                                      updateAssetConfig('uiButtonPositions', newPositions);
                                    }}
                                    className="w-full h-1.5 accent-blue-500"
                                  />
                                  <div className="flex justify-between text-xs uw:text-xl text-blue-600">
                                    <span>Left</span>
                                    <span>{(assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.x || 0}px</span>
                                    <span>Right</span>
                                  </div>
                                </div>

                                <div className='p-2 border rounded-md bg-gray-50'>
                                  <label className="text-xs uw:text-xl text-blue-700 mb- block">Vertical Offset</label>
                                  <input
                                    type="range"
                                    min="-100"
                                    max="100"
                                    value={(assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.y || 0}
                                    onChange={(e) => {
                                      const newPositions = {
                                        ...(assetConfig.uiButtonPositions || {}),
                                        [selectedUIButton]: {
                                          x: (assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.x || 0,
                                          y: parseInt(e.target.value)
                                        }
                                      };
                                      updateAssetConfig('uiButtonPositions', newPositions);
                                    }}
                                    className="w-full h-1.5 accent-blue-500"
                                  />
                                  <div className="flex justify-between text-xs uw:text-xl text-blue-600">
                                    <span>Up</span>
                                    <span>{(assetConfig.uiButtonPositions as any)?.[selectedUIButton]?.y || 0}px</span>
                                    <span>Down</span>
                                  </div>
                                  <p className="text-xs uw:text-xl text-blue-600 mt-1 text-center">
                                    Only affects the selected button
                                  </p>
                                </div>
                              </div>
                            ) : (
                              <div className="space-y-1">
                                <h6 className="text-xs uw:text-2xl pl-2 font-medium text-gray-800">Position</h6>
                                <div className='p-2 border rounded-md bg-gray-50'>
                                  <label className="text-xs uw:text-xl text-blue-700 block">Horizontal Offset</label>
                                  <input
                                    type="range"
                                    min="-200"
                                    max="200"
                                    value={assetConfig.uiButtonsPosition.x}
                                    onChange={(e) => updateAssetConfig('uiButtonsPosition', {
                                      ...assetConfig.uiButtonsPosition,
                                      x: parseInt(e.target.value)
                                    })}
                                    className="w-full h-1.5 accent-blue-500"
                                  />
                                  <div className="flex justify-between text-xs uw:text-xl text-blue-600">
                                    <span>Left</span>
                                    <span>{assetConfig.uiButtonsPosition.x}px</span>
                                    <span>Right</span>
                                  </div>
                                </div>

                                <div className='p-2 border rounded-md bg-gray-50'>
                                  <label className="text-xs uw:text-xl text-blue-700 mb- block">Vertical Offset</label>
                                  <input
                                    type="range"
                                    min="-100"
                                    max="100"
                                    value={assetConfig.uiButtonsPosition.y}
                                    onChange={(e) => updateAssetConfig('uiButtonsPosition', {
                                      ...assetConfig.uiButtonsPosition,
                                      y: parseInt(e.target.value)
                                    })}
                                    className="w-full h-1.5 accent-blue-500"
                                  />
                                  <div className="flex justify-between text-xs uw:text-xl text-blue-600">
                                    <span>Up</span>
                                    <span>{assetConfig.uiButtonsPosition.y}px</span>
                                    <span>Down</span>
                                  </div>
                                  <p className="text-xs uw:text-xl text-blue-600 mt-1 text-center">
                                    Select a button above to position individually
                                  </p>
                                </div>
                              </div>
                            )}

                            {/* Scale Control - Only shown when a button is selected */}
                            {selectedUIButton && (
                              <div className="space-y-1">
                                <div className="flex items-center justify-between pl-2">
                                  <h6 className="text-xs uw:text-xl font-medium text-gray-800">
                                    Scale: {selectedUIButton.replace('Button', '').toUpperCase()}
                                  </h6>
                                  {(assetConfig.uiButtonScales as any)?.[selectedUIButton] !== 100 && (assetConfig.uiButtonScales as any)?.[selectedUIButton] !== undefined && (
                                    <button
                                      onClick={() => {
                                        const newScales = {
                                          ...(assetConfig.uiButtonScales || {}),
                                          [selectedUIButton]: 100
                                        };
                                        updateAssetConfig('uiButtonScales', newScales);
                                      }}
                                      className="text-blue-600 hover:text-blue-800 hover:bg-blue-100 rounded p-1 transition-colors"
                                      title="Reset to 100%"
                                    >
                                      <RotateCcw className="w-4 h-4 uw:w-5 uw:h-5" />
                                    </button>
                                  )}
                                </div>
                                <div className='p-2 border rounded-md bg-gray-50'>
                                  <label className="text-xs uw:text-xl text-blue-700 block">
                                    {selectedUIButton.replace('Button', '').toUpperCase()} Button Size
                                  </label>
                                  <input
                                    type="range"
                                    min="50"
                                    max="200"
                                    value={(assetConfig.uiButtonScales as any)?.[selectedUIButton] || 100}
                                    onChange={(e) => {
                                      const newScales = {
                                        ...(assetConfig.uiButtonScales || {}),
                                        [selectedUIButton]: parseInt(e.target.value)
                                      };
                                      updateAssetConfig('uiButtonScales', newScales);
                                    }}
                                    className="w-full h-1.5 accent-blue-500"
                                  />
                                  <div className="flex justify-between text-xs uw:text-xl text-blue-600">
                                    <span>50%</span>
                                    <span>{(assetConfig.uiButtonScales as any)?.[selectedUIButton] || 100}%</span>
                                    <span>200%</span>
                                  </div>
                                  <p className="text-xs uw:text-xl text-blue-600 mt-1 text-center">
                                    Only affects the selected button
                                  </p>
                                </div>
                              </div>
                            )}

                            {/* Global Scale Control */}
                            {!selectedUIButton && (
                              <div className="space-y-1">
                                <div className="flex items-center justify-between pl-2">
                                  <h6 className="text-xs uw:text-xl font-medium text-gray-800">Global Scale</h6>
                                  {assetConfig.uiButtonsScale !== 100 && (
                                    <button
                                      onClick={() => updateAssetConfig('uiButtonsScale', 100)}
                                      className="text-blue-600 hover:text-blue-800 hover:bg-blue-100 rounded p-1 transition-colors"
                                      title="Reset to 100%"
                                    >
                                      <RotateCcw className="w-4 h-4 uw:w-5 uw:h-5" />
                                    </button>
                                  )}
                                </div>
                                <div className='p-2 border rounded-md bg-gray-50'>
                                  <label className="text-xs uw:text-xl text-blue-700 block">All Buttons Size</label>
                                  <input
                                    type="range"
                                    min="50"
                                    max="200"
                                    value={assetConfig.uiButtonsScale}
                                    onChange={(e) => updateAssetConfig('uiButtonsScale', parseInt(e.target.value))}
                                    className="w-full h-1.5 accent-blue-500"
                                  />
                                  <div className="flex justify-between text-xs uw:text-xl text-blue-600">
                                    <span>50%</span>
                                    <span>{assetConfig.uiButtonsScale}%</span>
                                    <span>200%</span>
                                  </div>
                                  <p className="text-xs uw:text-xl text-blue-600 mt-1 text-center">
                                    Select a button above to scale individually
                                  </p>
                                </div>
                              </div>
                            )}

                            {/* Visibility Control */}
                            <div className="space-y-1">
                              <button
                                className="w-full text-xs uw:text-xl bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700 transition-colors"
                                onClick={() => {
                                  // Reset UI button controls
                                  updateAssetConfig('uiButtonsPosition', { x: 0, y: 0 });
                                  updateAssetConfig('uiButtonsScale', 100);
                                  updateAssetConfig('uiButtonScales', {
                                    spinButton: 100,
                                    autoplayButton: 100,
                                    menuButton: 100,
                                    soundButton: 100,
                                    settingsButton: 100
                                  });
                                  updateAssetConfig('uiButtonPositions', {
                                    spinButton: { x: 0, y: 0 },
                                    autoplayButton: { x: 0, y: 0 },
                                    menuButton: { x: 0, y: 0 },
                                    soundButton: { x: 0, y: 0 },
                                    settingsButton: { x: 0, y: 0 }
                                  });
                                  updateAssetConfig('uiButtonsVisibility', true);
                                  
                                  // Dispatch event to update SlotMachine immediately
                                  window.dispatchEvent(new CustomEvent('uiButtonAdjustmentsUpdated', {
                                    detail: {
                                      position: { x: 0, y: 0 },
                                      scale: 100,
                                      buttonScales: {
                                        spinButton: 100,
                                        autoplayButton: 100,
                                        menuButton: 100,
                                        soundButton: 100,
                                        settingsButton: 100
                                      },
                                      buttonPositions: {
                                        spinButton: { x: 0, y: 0 },
                                        autoplayButton: { x: 0, y: 0 },
                                        menuButton: { x: 0, y: 0 },
                                        soundButton: { x: 0, y: 0 },
                                        settingsButton: { x: 0, y: 0 }
                                      },
                                      visibility: true
                                    }
                                  }));
                                }}
                              >
                                Reset to Default
                              </button>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>

          </div>
        </div>

        {/* winDisplayImage */}
        <div className="bg-white rounded-lg shadow-sm border border-gray-200">
           {/* Win Display generation / upload */}
                <div className="mt-4 border-t pt-4">
                  <h4 className="text-lg uw:text-3xl font-medium text-gray-700 mb-2">Win Display</h4>
                  <textarea
                    className="w-full h-20 p-3 border border-gray-300 rounded-md resize-none uw:text-xl mb-2"
                    placeholder="Describe the win display image (e.g., 'golden confetti burst with animated sparkles')"
                    value={assetConfig.winDisplayPrompt}
                    onChange={(e) => updateAssetConfig('winDisplayPrompt', e.target.value)}
                  />
                  <div className="flex gap-2">
                    <Button
                      variant="generate"
                      onClick={generateWinDisplay}
                      className='py-2 w-[50%]'
                      disabled={assetConfig.isGeneratingWinDisplay}
                    >
                      {assetConfig.isGeneratingWinDisplay ? (
                        <>
                          <Loader className="w-5 h-5 animate-spin" />
                          Generating...
                        </>
                      ) : (
                        <>
                          <Sparkles className="w-5 h-5" />
                          Generate Win Display
                        </>
                      )}
                    </Button>

                    <Button
                      variant="uploadImage"
                      className='py-2 w-[50%]'
                      onClick={() => winDisplayFileInputRef.current?.click()}
                    >
                      <Upload className="w-5 h-5" />
                      Upload Win Image
                    </Button>
                    <input
                      type="file"
                      ref={winDisplayFileInputRef}
                      className="hidden"
                      accept="image/png,image/jpeg,image/jpg,image/gif,image/webp"
                      onChange={handleWinDisplayUpload}
                      key="windisplay-upload"
                    />
                  </div>
                </div>
             {/* Preview win display image */}
            {assetConfig.winDisplayImage && (
              <div className="mt-4 p-3 bg-gray-50 rounded-md">
                <h4 className="text-sm uw:text-2xl font-medium text-gray-700 mb-2">Current Win Display</h4>
                <div 
                  className="relative bg-gray-200 rounded-md overflow-hidden h-36 flex items-center justify-center cursor-pointer hover:ring-2 hover:ring-yellow-400 transition-all duration-200"
                  onClick={() => window.dispatchEvent(new CustomEvent('winDisplayUpdated', { detail: { winDisplayUrl: assetConfig.winDisplayImage } }))}
                  title="Click to preview win display"
                >
                  <img
                    src={assetConfig.winDisplayImage}
                    alt="Win Display"
                    className="max-w-full max-h-full object-contain"
                  />
                </div>
              </div>
            )}

            {/* Win Display Positioning Controls */}
            {assetConfig.winDisplayImage && (
              <div className="p-4 bg-gray-50 border border-gray-200 rounde">
                <h4 className="text-sm uw:text-3xl font-medium text-yellow-800 mb-3 flex items-center">
                  <Move className="w-4 h-4 uw:w-6 uw:h-6 mr-2" />
                  Interactive Win Display Positioning
                </h4>

                {/* Manual controls as backup */}
                <div className="flex flex-col items-center justify-center w-full">
                  <div className='w-full p-3'>
                    <label className="text-xs uw:text-xl text-gray-600 flex items-center mb-1">
                      <ZoomIn className="w-3 h-3 uw:w-6 uw:h-6 mr-2" />
                      Size: {assetConfig.winDisplayScales[assetConfig.currentDevice]}%
                    </label>
                    <input
                      type="range"
                      min="50"
                      max="150"
                      value={assetConfig.winDisplayScales[assetConfig.currentDevice]}
                      onChange={(e) => {
                        const newScales = {
                          ...assetConfig.winDisplayScales,
                          [assetConfig.currentDevice]: parseInt(e.target.value)
                        };
                        updateAssetConfig('winDisplayScales', newScales);
                      }}
                      className="w-full"
                    />
                  </div>
<div className='grid grid-cols-2 gap-3 p-3 w-full'>
                  <div>
                    <label className="text-xs uw:text-xl text-gray-600 flex items-center mb-1">
                      <ArrowLeftRight className="w-3 h-3 uw:w-6 uw:h-6 mr-2" />
                      X: {assetConfig.winDisplayPositions[assetConfig.currentDevice].x}% (50% = center)
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={assetConfig.winDisplayPositions[assetConfig.currentDevice].x}
                      onChange={(e) => {
                        const newPositions = {
                          ...assetConfig.winDisplayPositions,
                          [assetConfig.currentDevice]: {
                            ...assetConfig.winDisplayPositions[assetConfig.currentDevice],
                            x: parseInt(e.target.value)
                          }
                        };
                        updateAssetConfig('winDisplayPositions', newPositions);
                      }}
                      className="w-full"
                    />
                    <div className="flex justify-between text-xs uw:text-xl text-gray-500 mt-1">
                      <span>(0%)</span>
                      <span>(50%)</span>
                      <span>(100%)</span>
                    </div>
                  </div>
                  <div>
                    <label className="text-xs uw:text-xl text-gray-600 flex items-center mb-1">
                      <ArrowUpDown className="w-3 h-3 uw:w-6 uw:h-6 mr-2" />
                      Y: {assetConfig.winDisplayPositions[assetConfig.currentDevice].y}% (20% = top)
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={assetConfig.winDisplayPositions[assetConfig.currentDevice].y}
                      onChange={(e) => {
                        const newPositions = {
                          ...assetConfig.winDisplayPositions,
                          [assetConfig.currentDevice]: {
                            ...assetConfig.winDisplayPositions[assetConfig.currentDevice],
                            y: parseInt(e.target.value)
                          }
                        };
                        updateAssetConfig('winDisplayPositions', newPositions);
                      }}
                      className="w-full"
                    />
                    <div className="flex justify-between text-xs uw:text-xl text-gray-500 mt-1">
                      <span>(0%)</span>
                      <span>(50%)</span>
                      <span>(100%)</span>
                    </div>
                  </div>
                </div>
</div>
                <div className="mt-3 flex items-center justify-end text-xs uw:text-2xl">
                  <button
                    onClick={() => {
                      const defaultPos = { x: 50, y: 20 };
                      const defaultScale = 80;
                      const newPositions = {
                        ...assetConfig.winDisplayPositions,
                        [assetConfig.currentDevice]: defaultPos
                      };
                      const newScales = {
                        ...assetConfig.winDisplayScales,
                        [assetConfig.currentDevice]: defaultScale
                      };
                      updateAssetConfig('winDisplayPositions', newPositions);
                      updateAssetConfig('winDisplayScales', newScales);
                    }}
                    className="text-yellow-600 hover:text-yellow-800 flex items-center gap-1"
                  >
                    <RotateCcw className="w-3 h-3 uw:w-6 uw:h-6 mr-1" />
                    Reset {assetConfig.currentDevice}
                  </button>
                </div>
              </div>
            )}
        </div>
        {/* Logo section */}
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 mb-4">
          <div className="px-4 py-3 uw:px-8 border-b border-gray-200 border-l-4 border-l-red-500 bg-gray-50">
            <h3 className="text-lg uw:text-3xl font-semibold text-gray-800 flex items-center">
              Game Logo (Brand Identity)
            </h3>
          </div>

          <div className="p-6">
            <div className="flex flex-col gap-4">
              <div className="col-span-2">
                <textarea
                  className="w-full h-24 p-3 border border-gray-300 rounded-md resize-none uw:text-xl"
                  placeholder="Describe your game logo (e.g., 'Ancient Egyptian pharaoh crown with golden hieroglyphs')"
                  value={assetConfig.logoPrompt}
                  onChange={(e) => updateAssetConfig('logoPrompt', e.target.value)}
                />
                <p className="text-xs uw:text-xl text-gray-500 mt-1">
                  AI will generate a professional game logo that matches your theme
                </p>
              </div>

              <div className="flex w-full gap-2">
                <Button
                  variant='generate'
                  className='py-2 w-[50%]'
                  onClick={generateLogo}
                  disabled={assetConfig.isGeneratingLogo}
                >
                  {assetConfig.isGeneratingLogo ? (
                    <>
                      <Loader className="w-5 h-5 animate-spin" />
                      Generating...
                    </>
                  ) : (
                    <>
                      <Sparkles className="w-5 h-5" />
                      Generate
                    </>
                  )}
                </Button>

                <Button
                  variant='uploadImage'
                  className='py-2 w-[50%]'
                  onClick={() => logoFileInputRef.current?.click()}
                >
                  <Upload className="w-5 h-5" />
                  Upload Logo
                </Button>
                <input
                  type="file"
                  ref={logoFileInputRef}
                  className="hidden"
                  accept="image/png,image/jpeg,image/jpg,image/gif,image/webp"
                  onChange={handleLogoUpload}
                  key="logo-upload"
                />
              </div>
            </div>

            {/* Logo Positioning Controls */}
            {assetConfig.logoPath && (
              <div className="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-md">
                <h4 className="text-sm uw:text-3xl font-medium text-blue-800 mb-3 flex items-center">
                  <Move className="w-4 h-4 uw:w-6 uw:h-6 mr-2" />
                  Interactive Logo Positioning
                </h4>

                <div className="bg-blue-100 p-3 rounded-md mb-4">
                  <div className="flex items-center justify-between mb-2">
                    <p className="text-sm uw:text-2xl text-blue-800 font-medium">ðŸŽ¯ Position your logo in the preview!</p>
                    <div className="text-xs text-blue-600 bg-blue-200 px-2 py-1 rounded">
                      {assetConfig.currentDevice === 'desktop' && 'ðŸ–¥ï¸ Desktop'}
                      {assetConfig.currentDevice === 'mobilePortrait' && 'ðŸ“± Mobile Portrait'}
                      {assetConfig.currentDevice === 'mobileLandscape' && 'ðŸ“± Mobile Landscape'}
                    </div>
                  </div>
                  <p className="text-xs uw:text-xl text-blue-700">
                    Look at the slot game preview on the right â†’ The logo should now be draggable!<br />
                    â€¢ <strong>Device-specific positioning</strong> - each orientation saves separately<br />
                    â€¢ <strong>Blue grid lines</strong> will appear to help with alignment<br />
                    â€¢ <strong>Drag the logo</strong> to position it exactly where you want<br />
                    â€¢ <strong>Resize your window</strong> to test different orientations
                  </p>
                </div>

                {/* Manual controls as backup */}
                <div className="grid grid-cols-3 gap-3">
                  <div>
                    <label className="text-xs uw:text-xl text-gray-600 flex items-center mb-1">
                      <ZoomIn className="w-3 h-3 uw:w-6 uw:h-6 mr-2" />
                      Size: {assetConfig.logoScales[assetConfig.currentDevice]}%
                    </label>
                    <input
                      type="range"
                      min="50"
                      max="150"
                      value={assetConfig.logoScales[assetConfig.currentDevice]}
                      onChange={(e) => {
                        const newScales = {
                          ...assetConfig.logoScales,
                          [assetConfig.currentDevice]: parseInt(e.target.value)
                        };
                        updateAssetConfig('logoScales', newScales);
                      }}
                      className="w-full"
                    />
                  </div>

                  <div>
                    <label className="text-xs uw:text-xl text-gray-600 flex items-center mb-1">
                      <ArrowLeftRight className="w-3 h-3 uw:w-6 uw:h-6 mr-2" />
                      X: {assetConfig.logoPositions[assetConfig.currentDevice].x}% (50% = center)
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={assetConfig.logoPositions[assetConfig.currentDevice].x}
                      onChange={(e) => {
                        const newPositions = {
                          ...assetConfig.logoPositions,
                          [assetConfig.currentDevice]: {
                            ...assetConfig.logoPositions[assetConfig.currentDevice],
                            x: parseInt(e.target.value)
                          }
                        };
                        updateAssetConfig('logoPositions', newPositions);
                      }}
                      className="w-full"
                    />
                    <div className="flex justify-between text-xs uw:text-xl text-gray-500 mt-1">
                      <span>(0%)</span>
                      <span>(50%)</span>
                      <span>(100%)</span>
                    </div>
                  </div>

                  <div>
                    <label className="text-xs uw:text-xl text-gray-600 flex items-center mb-1">
                      <ArrowUpDown className="w-3 h-3 uw:w-6 uw:h-6 mr-2" />
                      Y: {assetConfig.logoPositions[assetConfig.currentDevice].y}% (10% = top)
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={assetConfig.logoPositions[assetConfig.currentDevice].y}
                      onChange={(e) => {
                        const newPositions = {
                          ...assetConfig.logoPositions,
                          [assetConfig.currentDevice]: {
                            ...assetConfig.logoPositions[assetConfig.currentDevice],
                            y: parseInt(e.target.value)
                          }
                        };
                        updateAssetConfig('logoPositions', newPositions);
                      }}
                      className="w-full"
                    />
                    <div className="flex justify-between text-xs uw:text-xl text-gray-500 mt-1">
                      <span>(0%)</span>
                      <span>(50%)</span>
                      <span>(100%)</span>
                    </div>
                  </div>
                </div>

                <div className="mt-3 flex items-center justify-between text-xs uw:text-2xl">
                  <span className="text-gray-600">
                    {assetConfig.currentDevice}: x:{assetConfig.logoPositions[assetConfig.currentDevice].x}%, y:{assetConfig.logoPositions[assetConfig.currentDevice].y}%
                  </span>
                  <button
                    onClick={() => {
                      const defaultPos = getDefaultLogoPosition(assetConfig.currentDevice);
                      const newPositions = {
                        ...assetConfig.logoPositions,
                        [assetConfig.currentDevice]: defaultPos
                      };
                      updateAssetConfig('logoPositions', newPositions);
                    }}
                    className="text-blue-600 hover:text-blue-800 flex items-center gap-1"
                  >
                    <RotateCcw className="w-3 h-3 uw:w-6 uw:h-6 mr-1" />
                    Reset {assetConfig.currentDevice}
                  </button>
                </div>
              </div>
            )}

            {/* Preview current logo */}
            {assetConfig.logoPath && (
              <div className="mt-4 p-3 bg-gray-50 rounded-md ">
                <h4 className="text-sm uw:text-2xl font-medium text-gray-700 mb-2">Current Logo</h4>
                <div className="bg-gray-200 rounded-md overflow-hidden h-32 flex items-center justify-center">
                  <img
                    src={assetConfig.logoPath}
                    alt="Game Logo"
                    className="max-w-full max-h-full object-contain"
                  />
                </div>
              </div>
            )}

            {/* Logo usage guide */}
            <div className="mt-4 p-3 bg-gray-50 rounded-md border border-gay-200">
              <h4 className="text-sm uw:text-2xl font-medium text-gray-800 mb-2 flex items-center">
                <Info className="w-4 h-4 uw:w-6 uw:h-6 mr-1" />
                Logo Usage Guide
              </h4>
              <div className="text-xs uw:text-xl text-gray-700 space-y-1">
                <p>â€¢ Logo will appear at the top center of your game interface</p>
                <p>â€¢ Recommended size: 200-400px width for optimal readability</p>
                <p>â€¢ Use transparent background logos for best integration</p>
                <p>â€¢ Consider brand consistency across all game assets</p>
              </div>
            </div>
          </div>
        </div>
     </div>
    );
  };

  // Render the advanced tab
  const renderAdvancedTab = () => {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 mb-4">
        <div className="px-4 py-3 border-b border-gray-200 border-l-4 border-l-red-500 bg-gray-50">
          <h3 className="font-semibold text-gray-900">
            Grid & Symbol Positioning
          </h3>
        </div>

        <div className="p-6 space-y-6">
          {/* Symbol Square Grid Toggle */}
          <div className="flex items-center border justify-between p-4 bg-gray-50 rounded-md">
            <div>
              <h4 className="font-medium text-gray-800 flex items-center">
                <Grid3X3 className="w-4 h-4 mr-2" />
                Symbol Square Grid
              </h4>
              <p className="text-sm text-gray-600 mt-1">
                Show or hide the square backgrounds behind each symbol
              </p>
            </div>
            <button
              className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                assetConfig.showSymbolGrid ? 'bg-blue-600' : 'bg-gray-300'
              }`}
              onClick={() => {
                const currentState = assetConfig.showSymbolGrid;
                const newState = !currentState;
                
                // Update all states immediately
                updateAssetConfig('showSymbolGrid', newState);
                setSymbolGridClicked(true);
                localStorage.setItem('symbolGridActive', JSON.stringify(newState));
                
                // Update global config (inverted because showSymbolBackgrounds is opposite)
                updateConfig({ showSymbolBackgrounds: !newState });
              }}
            >
              <span
                className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                  assetConfig.showSymbolGrid ? 'translate-x-6' : 'translate-x-1'
                }`}
              />
              <span className="sr-only">Toggle symbol grid</span>
            </button>
          </div>

          {/* Grid Position Controls */}
          <div className="space-y-4 border p-2 rounded-md bg-gray-50">
            <h4 className="font-medium text-gray-800 flex items-center">
              <Move className="w-4 h-4 mr-2" />
              Grid Position
            </h4>
            <p className="text-sm text-gray-600">
              Adjust the position of the entire symbol grid.
            </p>

            <div className="grid grid-cols-2 gap-4">
              {/* Horizontal Position */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm text-gray-600 flex items-center">
                    <ArrowLeftRight className="w-3 h-3 mr-1" />
                    Horizontal Offset
                  </label>
                  <span className="text-sm text-gray-600">{assetConfig.gridPosition.x}px</span>
                </div>
                <input
                  type="range"
                  min="-200"
                  max="200"
                  value={assetConfig.gridPosition.x}
                  onChange={(e) => updateAssetConfig('gridPosition', { ...assetConfig.gridPosition, x: parseInt(e.target.value) })}
                  className="w-full"
                />
                <p className="text-xs text-gray-500 mt-1">
                  Move grid left (negative) or right (positive)
                </p>
              </div>

              {/* Vertical Position */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm text-gray-600 flex items-center">
                    <ArrowUpDown className="w-3 h-3 mr-1" />
                    Vertical Offset
                  </label>
                  <span className="text-sm text-gray-600">{assetConfig.gridPosition.y}px</span>
                </div>
                <input
                  type="range"
                  min="-200"
                  max="200"
                  value={assetConfig.gridPosition.y}
                  onChange={(e) => updateAssetConfig('gridPosition', { ...assetConfig.gridPosition, y: parseInt(e.target.value) })}
                  className="w-full"
                />
                <p className="text-xs text-gray-500 mt-1">
                  Move grid up (negative) or down (positive)
                </p>
              </div>
            </div>
          </div>

          {/* Grid Scale Control */}
          <div className="space-y-4 border p-2 rounded-md bg-gray-50">
            <h4 className="font-medium text-gray-800 flex items-center">
              <ZoomIn className="w-4 h-4 mr-2" />
              Grid Scale
            </h4>
            <div>
              <div className="flex justify-between mb-1">
                <label className="text-sm text-gray-600">Overall Grid Size</label>
                <span className="text-sm text-gray-600">
                  {/* Display normalized value (100 when actual is 120) */}
                  {Math.round((assetConfig.gridScale / 120) * 100)}%
                </span>
              </div>
              <input
                type="range"
                min="50"
                max="150"
                value={Math.round((assetConfig.gridScale / 120) * 100)}
                onChange={(e) => {
                  // Convert slider value (100 = baseline) to actual scale (120 = baseline)
                  const sliderValue = parseInt(e.target.value);
                  const actualScale = Math.round((sliderValue / 100) * 120);
                  updateAssetConfig('gridScale', actualScale);
                }}
                className="w-full"
              />
              <p className="text-xs text-gray-500 mt-1">
                Scale the entire grid up or down while maintaining position
              </p>
            </div>
          </div>

          {/* Grid Stretch Control */}
          <div className="space-y-4 border p-2 rounded-md bg-gray-50">
            <h4 className="font-medium text-gray-800 flex items-center">
              <Maximize className="w-4 h-4 mr-2" />
              Grid Stretch
            </h4>
            <div className='flex justify-center gap-4'>

              {/* Horizontal stretch */}
              <div className='w-full'>
                <div className="flex justify-between mb-1">
                  <label className="text-sm text-gray-600">Horizontal Stretch</label>
                  <span className="text-sm text-gray-600">{assetConfig.gridStretch.x}%</span>
                </div>
                <input
                  type="range"
                  min="80"
                  max="120"
                  value={assetConfig.gridStretch.x}
                  onChange={(e) => updateAssetConfig('gridStretch', { ...assetConfig.gridStretch, x: parseInt(e.target.value) })}
                  className="w-full"
                />
              </div>

              {/* Vertical stretch */}
              <div className='w-full'>
                <div className="flex justify-between mb-1">
                  <label className="text-sm text-gray-600">Vertical Stretch</label>
                  <span className="text-sm text-gray-600">{assetConfig.gridStretch.y}%</span>
                </div>
                <input
                  type="range"
                  min="80"
                  max="120"
                  value={assetConfig.gridStretch.y}
                  onChange={(e) => updateAssetConfig('gridStretch', { ...assetConfig.gridStretch, y: parseInt(e.target.value) })}
                  className="w-full"
                />
              </div>
            </div>

            <p className="text-xs text-gray-500">
              Stretch the grid independently in horizontal or vertical direction
            </p>
          </div>



          {/* Example use case */}
          <div className="bg-gray-50 border border-gray-200 rounded-md p-4">
            <div className="flex items-start">
              <AlertCircle className="w-5 h-5 text-gray-500 mr-2 mt-0.5" />
              <div>
                <h5 className="font-medium text-gray-800 mb-1">Example Use Case</h5>
                <p className="text-sm text-gray-700">
                  If you want to add a meter on the left side of your slot game, you can:
                  <br />â€¢ Move the grid right by setting Horizontal Offset to +100px
                  <br />â€¢ Scale down the grid to 85% to make room
                  <br />â€¢ Hide the symbol grid backgrounds for a cleaner look
                </p>
              </div>
            </div>
          </div>
          {/* Reset button */}
          <div className="flex justify-end">
            <Button
              variant='uploadImage'
              className='py-1 px-2'
              onClick={() => {
                updateAssetConfig('showSymbolGrid', true);
                updateAssetConfig('gridPosition', { x: 0, y: 0 });
                updateAssetConfig('gridScale', 120); // Reset to 120 (displays as 100 in slider)
                updateAssetConfig('gridStretch', { x: 100, y: 100 });
              }}
            >
              <RefreshCw className="w-4 h-4" />
              Reset to Default
            </Button>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="step-container p-4 sm:p-6 lg:p-0">
      <div className="max-w-7xl uw:max-w-full mx-auto">
        {/* Tab selector */}
        <div className="flex justify-center mb-6">
          <div className="inline-flex p-1 gap-2 bg-gray-100 rounded-lg">
            <button
              className={`px-4 py-2 text-sm uw:text-xl font-medium border border-gray-200 rounded-md transition-colors ${activeTab === 'preset'
                ? 'text-white bg-blue-500 shadow-sm'
                : 'text-gray-600 hover:text-gray-800'
                }`}
              onClick={() => setActiveTab('preset')}
            >
              <Wand2 className="w-4 h-4 uw:w-6 uw:h-6 inline mr-1" />
              Preset
            </button>
            <button
              className={`px-4 py-2 text-sm uw:text-xl font-medium border border-gray-200 rounded-md transition-colors ${activeTab === 'advanced'
                ? 'text-white bg-blue-500 shadow-sm'
                : 'text-gray-600 hover:text-gray-800'
                }`}
              onClick={() => setActiveTab('advanced')}
            >
              <Settings className="w-4 h-4 uw:w-6 uw:h-6 inline mr-1" />
              Advanced
            </button>
          </div>
        </div>

        {/* Main content area */}
        <div className="w-full">
          {/* Asset controls */}
          <div className="space-y-6">
            <AnimatePresence mode="wait">
              <motion.div
                key={activeTab}
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.2 }}
              >
                {activeTab === 'preset' ? renderPresetTab() : renderAdvancedTab()}
              </motion.div>
            </AnimatePresence>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Step6_GameAssets;